{"file_contents":{"app.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPharmaEvents - Minimal Flask Application\n\"\"\"\n\nimport os\nimport io\nimport csv\nimport secrets\nimport hashlib\nfrom datetime import datetime, timedelta\nfrom functools import wraps\nfrom flask import Flask, render_template, request, redirect, url_for, flash, make_response, jsonify, abort\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\nfrom flask_caching import Cache\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nimport pandas as pd\nimport logging\nfrom logging.handlers import RotatingFileHandler\n\n# Load environment variables from .env file\ntry:\n    from dotenv import load_dotenv\n    load_dotenv()\n    print(\"✓ Loaded environment variables from .env file\")\nexcept ImportError:\n    print(\"⚠ python-dotenv not installed, using system environment variables\")\n\n# Egyptian governorates list\negyptian_governorates = [\n    'Cairo', 'Giza', 'Alexandria', 'Dakahlia', 'Red Sea', 'Beheira', 'Fayoum',\n    'Gharbiya', 'Ismailia', 'Menofia', 'Minya', 'Qaliubiya', 'New Valley',\n    'Suez', 'Aswan', 'Assiut', 'Beni Suef', 'Port Said', 'Damietta',\n    'Sharkia', 'South Sinai', 'Kafr El Sheikh', 'Matrouh', 'Luxor',\n    'Qena', 'North Sinai', 'Sohag'\n]\n\n# Validate required environment variables\nrequired_env_vars = [\"DATABASE_URL\", \"SESSION_SECRET\", \"ADMIN_EMAIL\", \"ADMIN_PASSWORD\"]\nmissing_vars = [var for var in required_env_vars if not os.environ.get(var)]\nif missing_vars:\n    raise RuntimeError(f\"Missing required environment variables: {', '.join(missing_vars)}. Please check your .env file.\")\n\n# Create app with configuration from .env\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\")\napp.config['REMEMBER_COOKIE_HTTPONLY'] = os.environ.get('REMEMBER_COOKIE_HTTPONLY', 'True').lower() == 'true'\napp.config['SESSION_COOKIE_HTTPONLY'] = os.environ.get('SESSION_COOKIE_HTTPONLY', 'True').lower() == 'true'\napp.config['SESSION_COOKIE_SAMESITE'] = os.environ.get('SESSION_COOKIE_SAMESITE', 'Lax')\napp.config['SESSION_COOKIE_SECURE'] = os.environ.get('SESSION_COOKIE_SECURE', 'False').lower() == 'true'\napp.config['WTF_CSRF_TIME_LIMIT'] = int(os.environ.get('CSRF_TIME_LIMIT', '3600'))\napp.config['MAX_CONTENT_LENGTH'] = int(os.environ.get('MAX_UPLOAD_SIZE', '16777216'))  # 16MB default\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Configure database - PostgreSQL only from .env\ndatabase_url = os.environ.get(\"DATABASE_URL\")\nif not database_url or not database_url.startswith(('postgresql://', 'postgres://')):\n    raise RuntimeError(\"DATABASE_URL must be a PostgreSQL connection string\")\n\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = database_url\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = os.environ.get('SQLALCHEMY_TRACK_MODIFICATIONS', 'False').lower() == 'true'\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_size\": int(os.environ.get('DB_POOL_SIZE', '20')),\n    \"max_overflow\": int(os.environ.get('DB_MAX_OVERFLOW', '50')),\n    \"pool_timeout\": int(os.environ.get('DB_POOL_TIMEOUT', '10')),\n    \"pool_recycle\": int(os.environ.get('DB_POOL_RECYCLE', '3600')),\n    \"pool_pre_ping\": os.environ.get('DB_POOL_PRE_PING', 'True').lower() == 'true',\n    \"pool_reset_on_return\": os.environ.get('DB_POOL_RESET_ON_RETURN', 'commit'),\n    \"connect_args\": {\n        \"options\": \"-c statement_timeout=30000 -c lock_timeout=10000 -c idle_in_transaction_session_timeout=300000\",\n        \"connect_timeout\": 30\n    }\n}\n\n# Initialize database\ndb = SQLAlchemy(app)\n\n# Initialize caching\ncache = Cache(app, config={\n    'CACHE_TYPE': 'simple',  # Use simple in-memory cache for development\n    'CACHE_DEFAULT_TIMEOUT': int(os.environ.get('CACHE_TIMEOUT', '300'))  # 5 minutes default\n})\n\n# Initialize rate limiter\nlimiter = Limiter(\n    key_func=get_remote_address,\n    app=app,\n    default_limits=[\"200 per day\", \"50 per hour\"],\n    storage_uri=\"memory://\",\n    headers_enabled=True\n)\n\n# Configure security logging\nsecurity_logger = logging.getLogger('security')\nsecurity_logger.setLevel(logging.INFO)\nif not os.path.exists('logs'):\n    os.makedirs('logs')\nsecurity_handler = RotatingFileHandler('logs/security.log', maxBytes=10240000, backupCount=10)\nsecurity_handler.setFormatter(logging.Formatter(\n    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n))\nsecurity_logger.addHandler(security_handler)\n\n# Initialize login manager\nlogin_manager = LoginManager(app)\nlogin_manager.login_view = 'login'  # type: ignore\nlogin_manager.login_message = \"Please log in to access this page.\"\nlogin_manager.login_message_category = \"info\"\n\n# User model\nclass User(UserMixin, db.Model):\n    __tablename__ = 'users'\n    id = db.Column(db.Integer, primary_key=True)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(256), nullable=False)\n    role = db.Column(db.String(20), default='user')\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\n    def is_admin(self):\n        return self.role == 'admin'\n\n    def is_event_manager(self):\n        return self.role == 'event_manager'\n\n    def is_medical_rep(self):\n        return self.role == 'medical_rep'\n\n    def can_approve_events(self):\n        return self.role in ['admin', 'event_manager']\n\n# App Settings model for persistent configuration\nclass AppSetting(db.Model):\n    __tablename__ = 'app_settings'\n    id = db.Column(db.Integer, primary_key=True)\n    key = db.Column(db.String(100), unique=True, nullable=False)\n    value = db.Column(db.Text, nullable=True)\n\n    @classmethod\n    def get_setting(cls, key, default=None):\n        try:\n            setting = cls.query.filter_by(key=key).first()\n            return setting.value if setting else default\n        except Exception as e:\n            db.session.rollback()\n            app.logger.error(f'Error getting setting {key}: {str(e)}')\n            return default\n\n    @classmethod\n    def set_setting(cls, key, value):\n        try:\n            setting = cls.query.filter_by(key=key).first()\n            if setting:\n                setting.value = value\n            else:\n                setting = cls(key=key, value=value)\n                db.session.add(setting)\n            db.session.commit()\n            return setting\n        except Exception as e:\n            db.session.rollback()\n            app.logger.error(f'Error setting {key}: {str(e)}')\n            return None\n\n# API Token model for API authentication\nclass APIToken(db.Model):\n    __tablename__ = 'api_tokens'\n    id = db.Column(db.Integer, primary_key=True)\n    token_hash = db.Column(db.String(256), unique=True, nullable=False)\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)\n    name = db.Column(db.String(100), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    last_used = db.Column(db.DateTime)\n    is_active = db.Column(db.Boolean, default=True)\n    \n    user = db.relationship('User', backref='api_tokens')\n    \n    @classmethod\n    def generate_token(cls, user_id, name):\n        \"\"\"Generate a new API token\"\"\"\n        token = secrets.token_urlsafe(32)\n        token_hash = hashlib.sha256(token.encode()).hexdigest()\n        api_token = cls(\n            token_hash=token_hash,\n            user_id=user_id,\n            name=name\n        )\n        db.session.add(api_token)\n        db.session.commit()\n        return token, api_token\n    \n    @classmethod\n    def verify_token(cls, token):\n        \"\"\"Verify an API token and return the associated user\"\"\"\n        if not token:\n            return None\n        token_hash = hashlib.sha256(token.encode()).hexdigest()\n        api_token = cls.query.filter_by(token_hash=token_hash, is_active=True).first()\n        if api_token:\n            api_token.last_used = datetime.utcnow()\n            db.session.commit()\n            return api_token.user\n        return None\n\n# Security helper functions\ndef log_security_event(event_type, message, user_id=None, ip_address=None):\n    \"\"\"Log security events\"\"\"\n    try:\n        if not ip_address:\n            ip_address = get_remote_address()\n        \n        user_info = f\"User ID: {user_id}\" if user_id else \"Anonymous\"\n        security_logger.info(f\"{event_type} - {message} - {user_info} - IP: {ip_address}\")\n    except Exception as e:\n        app.logger.error(f\"Error logging security event: {str(e)}\")\n\ndef api_token_required(f):\n    \"\"\"Decorator for API endpoints requiring token authentication\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        token = request.headers.get('Authorization', '').replace('Bearer ', '')\n        if not token:\n            token = request.args.get('api_token')\n        \n        user = APIToken.verify_token(token)\n        if not user:\n            log_security_event(\"API_AUTH_FAILED\", \"Invalid or missing API token\")\n            return jsonify({'error': 'Invalid or missing API token'}), 401\n        \n        # Set current user for the request\n        login_user(user)\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef validate_file_size(file, max_size_mb=16):\n    \"\"\"Validate file size\"\"\"\n    if file:\n        file.seek(0, 2)  # Seek to end\n        file_size = file.tell()\n        file.seek(0)  # Reset to beginning\n        \n        max_size_bytes = max_size_mb * 1024 * 1024\n        if file_size > max_size_bytes:\n            return False, f\"File size exceeds {max_size_mb}MB limit\"\n    return True, \"OK\"\n\ndef validate_request_size():\n    \"\"\"Validate request content length\"\"\"\n    max_size = app.config.get('MAX_CONTENT_LENGTH', 16 * 1024 * 1024)  # 16MB default\n    if request.content_length and request.content_length > max_size:\n        log_security_event(\"LARGE_REQUEST\", f\"Request size {request.content_length} exceeds limit {max_size}\")\n        abort(413)  # Request Entity Too Large\n\n# Request size validation middleware\n@app.before_request\ndef check_request_size():\n    \"\"\"Check request size before processing\"\"\"\n    if request.content_length:\n        max_size = app.config.get('MAX_CONTENT_LENGTH', 16 * 1024 * 1024)\n        if request.content_length > max_size:\n            log_security_event(\"LARGE_REQUEST_BLOCKED\", f\"Request size {request.content_length} exceeds limit\")\n            abort(413)\n\n# Event Category model\nclass EventCategory(db.Model):\n    __tablename__ = 'event_category'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    description = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n# Event Type model\nclass EventType(db.Model):\n    __tablename__ = 'event_type'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    description = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n# Association table for many-to-many relationship between events and categories\nevent_categories = db.Table('event_categories',\n    db.Column('event_id', db.Integer, db.ForeignKey('event.id'), primary_key=True),\n    db.Column('category_id', db.Integer, db.ForeignKey('event_category.id'), primary_key=True)\n)\n\n# Event model\nclass Event(db.Model):\n    __tablename__ = 'event'\n    __table_args__ = (\n        # Basic indexes for common queries\n        db.Index('idx_event_start_datetime', 'start_datetime'),\n        db.Index('idx_event_user_id', 'user_id'),\n        db.Index('idx_event_status', 'status'),\n        db.Index('idx_event_created_at', 'created_at'),\n        db.Index('idx_event_is_online', 'is_online'),\n        db.Index('idx_event_type_id', 'event_type_id'),\n        db.Index('idx_event_end_datetime', 'end_datetime'),\n        \n        # Composite indexes for complex queries (order matters!)\n        db.Index('idx_event_user_status', 'user_id', 'status'),\n        db.Index('idx_event_user_start', 'user_id', 'start_datetime'),\n        db.Index('idx_event_user_created', 'user_id', 'created_at'),\n        db.Index('idx_event_start_status', 'start_datetime', 'status'),\n        db.Index('idx_event_status_start', 'status', 'start_datetime'),\n        db.Index('idx_event_user_online', 'user_id', 'is_online'),\n        db.Index('idx_event_user_end', 'user_id', 'end_datetime'),\n        \n        # Index for export operations\n        db.Index('idx_event_created_desc', 'created_at', postgresql_using='btree'),\n    )\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(200), nullable=False)\n    description = db.Column(db.Text)\n    event_type_id = db.Column(db.Integer, db.ForeignKey('event_type.id'))\n    is_online = db.Column(db.Boolean, default=False)\n    start_datetime = db.Column(db.DateTime, nullable=False)\n    end_datetime = db.Column(db.DateTime)\n    registration_deadline = db.Column(db.DateTime, nullable=False)\n    venue_id = db.Column(db.Integer, nullable=True)  # Could be linked to venue table later\n\n    governorate = db.Column(db.String(100))\n    image_file = db.Column(db.String(200), nullable=True)  # For storing event image filename\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)\n    status = db.Column(db.String(20), default='pending')  # pending, active, declined\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    # Relationships\n    event_type = db.relationship('EventType', backref='events')\n    creator = db.relationship('User', backref='created_events')\n    categories = db.relationship('EventCategory', secondary=event_categories, backref='events')\n\n@login_manager.user_loader\ndef load_user(user_id):\n    try:\n        return db.session.get(User, int(user_id))\n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error loading user {user_id}: {str(e)}')\n        return None\n\ndef recover_db_session():\n    \"\"\"Recover from database transaction errors\"\"\"\n    try:\n        db.session.rollback()\n        db.session.close()\n    except Exception:\n        pass\n\n# Utility functions for performance optimization\ndef get_paginated_events(page=1, per_page=20, user_filter=None, order_by='created_at', desc=True, status_filter=None, search_query=None):\n    \"\"\"\n    Get paginated events with optimized query and filtering.\n    Returns tuple: (events, total_count, has_next, has_prev)\n    \"\"\"\n    # Use optimized query with joinedload for related data\n    query = Event.query.options(\n        db.joinedload(Event.event_type),\n        db.joinedload(Event.creator),\n        db.joinedload(Event.categories)\n    )\n    \n    # Apply filters\n    if user_filter:\n        query = query.filter(Event.user_id == user_filter)\n    \n    if status_filter and status_filter != 'all':\n        query = query.filter(Event.status == status_filter)\n    \n    if search_query:\n        # Use indexed search on name field\n        query = query.filter(Event.name.ilike(f'%{search_query}%'))\n    \n    # Apply ordering using indexed columns\n    if order_by == 'created_at':\n        if desc:\n            query = query.order_by(Event.created_at.desc())\n        else:\n            query = query.order_by(Event.created_at.asc())\n    elif order_by == 'start_datetime':\n        if desc:\n            query = query.order_by(Event.start_datetime.desc())\n        else:\n            query = query.order_by(Event.start_datetime.asc())\n    \n    # Use optimized count query without loading all data\n    from sqlalchemy import func\n    total_count = db.session.query(func.count(Event.id)).filter(*[\n        condition for condition in [\n            Event.user_id == user_filter if user_filter else None,\n            Event.status == status_filter if status_filter and status_filter != 'all' else None,\n            Event.name.ilike(f'%{search_query}%') if search_query else None\n        ] if condition is not None\n    ]).scalar()\n    \n    # Apply pagination\n    offset = (page - 1) * per_page\n    events = query.offset(offset).limit(per_page).all()\n    \n    # Calculate pagination info\n    has_next = offset + per_page < total_count\n    has_prev = page > 1\n    \n    return events, total_count, has_next, has_prev\n\n@cache.memoize(timeout=300)  # Cache for 5 minutes\ndef get_dashboard_stats_cached(user_id, is_admin):\n    \"\"\"Get cached dashboard statistics\"\"\"\n    from sqlalchemy import func, case\n    now = datetime.now()\n    \n    # Single optimized query to get all counts\n    if is_admin:\n        stats = db.session.query(\n            func.count(Event.id).label('total_events'),\n            func.sum(case((Event.start_datetime > now, 1), else_=0)).label('upcoming_events'),\n            func.sum(case((Event.is_online == True, 1), else_=0)).label('online_events'),\n            func.sum(case((Event.status == 'pending', 1), else_=0)).label('pending_events'),\n            func.sum(case((Event.end_datetime < now, 1), else_=0)).label('completed_events')\n        ).first()\n    else:\n        stats = db.session.query(\n            func.count(Event.id).label('total_events'),\n            func.sum(case((Event.start_datetime > now, 1), else_=0)).label('upcoming_events'),\n            func.sum(case((Event.is_online == True, 1), else_=0)).label('online_events'),\n            func.sum(case((Event.status == 'pending', 1), else_=0)).label('pending_events'),\n            func.sum(case((Event.end_datetime < now, 1), else_=0)).label('completed_events')\n        ).filter(Event.user_id == user_id).first()\n    \n    return {\n        'total_events': stats.total_events or 0,\n        'upcoming_events': stats.upcoming_events or 0,\n        'online_events': stats.online_events or 0,\n        'offline_events': (stats.total_events or 0) - (stats.online_events or 0),\n        'pending_events': stats.pending_events or 0,\n        'completed_events': stats.completed_events or 0\n    }\n\n@cache.memoize(timeout=600)  # Cache for 10 minutes\ndef get_category_data_cached(user_id, is_admin):\n    \"\"\"Get cached category distribution data\"\"\"\n    from sqlalchemy import func\n    \n    if is_admin:\n        # Optimized query using database aggregation\n        result = db.session.query(\n            EventCategory.name,\n            func.count(Event.id).label('count')\n        ).join(\n            event_categories, EventCategory.id == event_categories.c.category_id\n        ).join(\n            Event, event_categories.c.event_id == Event.id\n        ).group_by(EventCategory.id, EventCategory.name).all()\n    else:\n        result = db.session.query(\n            EventCategory.name,\n            func.count(Event.id).label('count')\n        ).join(\n            event_categories, EventCategory.id == event_categories.c.category_id\n        ).join(\n            Event, event_categories.c.event_id == Event.id\n        ).filter(Event.user_id == user_id).group_by(EventCategory.id, EventCategory.name).all()\n    \n    categories_data = [{'name': row[0], 'count': row[1]} for row in result if row[1] > 0]\n    categories_data.sort(key=lambda x: x['count'], reverse=True)\n    \n    return categories_data\n\n@cache.memoize(timeout=600)  # Cache for 10 minutes\ndef get_monthly_data_cached(user_id, is_admin):\n    \"\"\"Get cached monthly event distribution\"\"\"\n    from sqlalchemy import func, extract\n    current_year = datetime.now().year\n    \n    if is_admin:\n        result = db.session.query(\n            extract('month', Event.start_datetime).label('month'),\n            func.count(Event.id).label('count')\n        ).filter(\n            extract('year', Event.start_datetime) == current_year\n        ).group_by(extract('month', Event.start_datetime)).all()\n    else:\n        result = db.session.query(\n            extract('month', Event.start_datetime).label('month'),\n            func.count(Event.id).label('count')\n        ).filter(\n            Event.user_id == user_id,\n            extract('year', Event.start_datetime) == current_year\n        ).group_by(extract('month', Event.start_datetime)).all()\n    \n    # Initialize all months with 0\n    monthly_counts = [0] * 12\n    for month, count in result:\n        if month:\n            monthly_counts[int(month) - 1] = count\n    \n    return {\n        'labels': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'data': monthly_counts\n    }\n\n@app.teardown_appcontext\ndef close_db_session(exception=None):\n    \"\"\"Ensure database sessions are properly closed\"\"\"\n    try:\n        if exception:\n            db.session.rollback()\n        else:\n            db.session.commit()\n    except Exception:\n        db.session.rollback()\n    finally:\n        db.session.remove()\n\n@app.errorhandler(500)\ndef internal_error(error):\n    \"\"\"Handle internal server errors\"\"\"\n    db.session.rollback()\n    app.logger.error(f'Internal server error: {error}')\n    flash('An internal error occurred. Please try again.', 'danger')\n    return redirect(url_for('dashboard'))\n\n@app.errorhandler(404)\ndef not_found_error(error):\n    \"\"\"Handle 404 errors\"\"\"\n    app.logger.warning(f'404 error: {error}')\n    flash('The requested page was not found.', 'warning')\n    return redirect(url_for('dashboard'))\n\n\n\n# Routes\n@app.route('/')\ndef index():\n    return redirect(url_for('login'))\n\n@app.route('/login', methods=['GET', 'POST'])\n@limiter.limit(\"10 per minute\")  # Stricter rate limiting for login\ndef login():\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard'))\n\n    if request.method == 'POST':\n        email = request.form.get('email')\n        password = request.form.get('password')\n\n        if not email or not password:\n            log_security_event(\"LOGIN_ATTEMPT_FAILED\", \"Missing email or password\", ip_address=get_remote_address())\n            flash('Please enter both email and password', 'danger')\n            app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n            theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n            app_logo = AppSetting.get_setting('app_logo')\n            return render_template('login.html', app_name=app_name, theme_color=theme_color, app_logo=app_logo)\n\n        user = User.query.filter_by(email=email).first()\n        if user and user.check_password(password):\n            login_user(user)\n            log_security_event(\"LOGIN_SUCCESS\", f\"User {email} logged in successfully\", user_id=user.id)\n            flash('Login successful!', 'success')\n            return redirect(url_for('dashboard'))\n        else:\n            log_security_event(\"LOGIN_FAILED\", f\"Failed login attempt for email: {email}\", ip_address=get_remote_address())\n            flash('Invalid email or password', 'danger')\n\n    app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n    theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n    app_logo = AppSetting.get_setting('app_logo')\n    main_tagline = AppSetting.get_setting('main_tagline')\n    main_header = AppSetting.get_setting('main_header')\n    app_description = AppSetting.get_setting('app_description')\n    feature1_title = AppSetting.get_setting('feature1_title')\n    feature1_description = AppSetting.get_setting('feature1_description')\n    feature2_title = AppSetting.get_setting('feature2_title')\n    feature2_description = AppSetting.get_setting('feature2_description')\n    return render_template('login.html', \n                         app_name=app_name, \n                         theme_color=theme_color,\n                         app_logo=app_logo,\n                         main_tagline=main_tagline,\n                         main_header=main_header,\n                         app_description=app_description,\n                         feature1_title=feature1_title,\n                         feature1_description=feature1_description,\n                         feature2_title=feature2_title,\n                         feature2_description=feature2_description)\n\n@app.route('/dashboard')\n@login_required\ndef dashboard():\n    # Get app settings\n    app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n    theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n\n    # Get filter parameters\n    search_query = request.args.get('search', '').strip()\n    category_filter = request.args.get('category', 'all')\n    type_filter = request.args.get('type', 'all')\n    date_filter = request.args.get('date', 'all')\n\n    # Get categories and event types for filter dropdowns\n    try:\n        categories = EventCategory.query.all()\n        event_types = EventType.query.all()\n    except Exception as e:\n        app.logger.error(f'Error fetching categories/types: {str(e)}')\n        categories = []\n        event_types = []\n\n    # Use cached dashboard statistics for better performance\n    try:\n        now = datetime.now()\n        \n        # Get cached stats (apply filters for statistics)\n        stats = get_filtered_dashboard_stats(\n            user_id=current_user.id,\n            is_admin=current_user.can_approve_events(),\n            search_query=search_query,\n            category_filter=category_filter,\n            type_filter=type_filter,\n            date_filter=date_filter\n        )\n        \n        total_events = stats['total_events']\n        upcoming_events = stats['upcoming_events']\n        online_events = stats['online_events']\n        offline_events = stats['offline_events']\n        pending_events_count = stats['pending_events']\n\n        # Apply filters to recent and upcoming events\n        if current_user.can_approve_events():\n            recent_query = Event.query.options(\n                db.joinedload(Event.event_type),\n                db.joinedload(Event.categories)\n            )\n            upcoming_query = Event.query.filter(Event.start_datetime > now).options(\n                db.joinedload(Event.event_type),\n                db.joinedload(Event.categories)\n            )\n        else:\n            recent_query = Event.query.filter_by(user_id=current_user.id).options(\n                db.joinedload(Event.event_type),\n                db.joinedload(Event.categories)\n            )\n            upcoming_query = Event.query.filter(Event.user_id == current_user.id, Event.start_datetime > now).options(\n                db.joinedload(Event.event_type),\n                db.joinedload(Event.categories)\n            )\n\n        # Apply search filter\n        if search_query:\n            search_filter = db.or_(\n                Event.name.ilike(f'%{search_query}%'),\n                Event.description.ilike(f'%{search_query}%'),\n                Event.location.ilike(f'%{search_query}%')\n            )\n            recent_query = recent_query.filter(search_filter)\n            upcoming_query = upcoming_query.filter(search_filter)\n\n        # Apply category filter\n        if category_filter != 'all':\n            try:\n                category_id = int(category_filter)\n                recent_query = recent_query.filter(Event.categories.any(EventCategory.id == category_id))\n                upcoming_query = upcoming_query.filter(Event.categories.any(EventCategory.id == category_id))\n            except (ValueError, TypeError):\n                pass\n\n        # Apply event type filter\n        if type_filter != 'all':\n            try:\n                type_id = int(type_filter)\n                recent_query = recent_query.filter_by(event_type_id=type_id)\n                upcoming_query = upcoming_query.filter_by(event_type_id=type_id)\n            except (ValueError, TypeError):\n                pass\n\n        # Apply date filter\n        if date_filter == 'upcoming':\n            recent_query = recent_query.filter(Event.start_datetime > now)\n        elif date_filter == 'past':\n            recent_query = recent_query.filter(Event.start_datetime < now)\n            upcoming_query = upcoming_query.filter(Event.start_datetime < now)\n        elif date_filter == 'this_month':\n            start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n            end_of_month = (start_of_month + timedelta(days=32)).replace(day=1) - timedelta(seconds=1)\n            recent_query = recent_query.filter(Event.start_datetime >= start_of_month, Event.start_datetime <= end_of_month)\n            upcoming_query = upcoming_query.filter(Event.start_datetime >= start_of_month, Event.start_datetime <= end_of_month)\n        elif date_filter == 'last_month':\n            first_of_this_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n            first_of_last_month = (first_of_this_month - timedelta(days=1)).replace(day=1)\n            last_of_last_month = first_of_this_month - timedelta(seconds=1)\n            recent_query = recent_query.filter(Event.start_datetime >= first_of_last_month, Event.start_datetime <= last_of_last_month)\n            upcoming_query = upcoming_query.filter(Event.start_datetime >= first_of_last_month, Event.start_datetime <= last_of_last_month)\n\n        recent_events = recent_query.order_by(Event.created_at.desc()).limit(5).all()\n        upcoming_events_list = upcoming_query.order_by(Event.start_datetime.asc()).limit(5).all()\n\n        # Get filtered chart data\n        category_data = get_filtered_category_data(current_user.id, current_user.can_approve_events(), search_query, category_filter, type_filter, date_filter)\n        event_type_data = get_filtered_type_data(current_user.id, current_user.can_approve_events(), search_query, category_filter, type_filter, date_filter)\n\n    except Exception as e:\n        app.logger.error(f'Error calculating dashboard stats: {str(e)}')\n        # Fallback values\n        total_events = 0\n        upcoming_events = 0\n        online_events = 0\n        offline_events = 0\n        pending_events_count = 0\n        recent_events = []\n        upcoming_events_list = []\n        category_data = []\n        event_type_data = []\n\n    app_logo = AppSetting.get_setting('app_logo')\n    return render_template('dashboard.html', \n                         app_name=app_name,\n                         app_logo=app_logo,\n                         theme_color=theme_color,\n                         total_events=total_events,\n                         upcoming_events=upcoming_events,  \n                         online_events=online_events,\n                         offline_events=offline_events,\n                         pending_events_count=pending_events_count,\n                         recent_events=recent_events,\n                         upcoming_events_list=upcoming_events_list,\n                         category_data=category_data,\n                         event_type_data=event_type_data,\n                         categories=categories,\n                         event_types=event_types,\n                         search_query=search_query,\n                         selected_category=category_filter,\n                         selected_type=type_filter,\n                         selected_date=date_filter)\n\n@app.route('/logout')\n@login_required\ndef logout():\n    logout_user()\n    return redirect(url_for('login'))\n\n@app.route('/events')\n@login_required\ndef events():\n    # Get common settings in a single batch query optimized call\n    settings_keys = ['app_name', 'theme_color', 'app_logo']\n    settings = {}\n    try:\n        for key in settings_keys:\n            settings[key] = AppSetting.get_setting(key, 'PharmaEvents' if key == 'app_name' else '#0f6e84' if key == 'theme_color' else None)\n    except Exception as e:\n        app.logger.error(f'Error fetching settings: {str(e)}')\n        settings = {'app_name': 'PharmaEvents', 'theme_color': '#0f6e84', 'app_logo': None}\n\n    # Simplified category and event type loading\n    try:\n        categories = EventCategory.query.order_by(EventCategory.name).all()\n        event_types = EventType.query.order_by(EventType.name).all()\n    except Exception as e:\n        app.logger.error(f'Error fetching categories/types: {str(e)}')\n        categories = []\n        event_types = []\n\n    # Get pagination parameters\n    page = request.args.get('page', 1, type=int)\n    per_page = min(request.args.get('per_page', 20, type=int), 100)  # Max 100 per page\n    \n    # Search and filter parameters\n    search_query = request.args.get('search', '').strip()\n    status_filter = request.args.get('status', 'all')\n    category_filter = request.args.get('category', 'all')\n    type_filter = request.args.get('type', 'all')\n    date_filter = request.args.get('date', 'all')\n    \n    # Build query with filters\n    try:\n        if current_user.can_approve_events():\n            query = Event.query.options(\n                db.joinedload(Event.event_type),\n                db.joinedload(Event.categories)\n            )\n        else:\n            query = Event.query.filter_by(user_id=current_user.id).options(\n                db.joinedload(Event.event_type),\n                db.joinedload(Event.categories)\n            )\n        \n        # Apply search filter (search in name, description, and location)\n        if search_query:\n            query = query.filter(\n                db.or_(\n                    Event.name.ilike(f'%{search_query}%'),\n                    Event.description.ilike(f'%{search_query}%'),\n                    Event.location.ilike(f'%{search_query}%')\n                )\n            )\n        \n        # Apply status filter\n        if status_filter != 'all':\n            query = query.filter_by(status=status_filter)\n            \n        # Apply category filter\n        if category_filter != 'all':\n            try:\n                category_id = int(category_filter)\n                query = query.filter(Event.categories.any(EventCategory.id == category_id))\n            except (ValueError, TypeError):\n                pass\n                \n        # Apply event type filter\n        if type_filter != 'all':\n            try:\n                type_id = int(type_filter)\n                query = query.filter_by(event_type_id=type_id)\n            except (ValueError, TypeError):\n                pass\n                \n        # Apply date filter\n        if date_filter == 'upcoming':\n            query = query.filter(Event.start_datetime > datetime.utcnow())\n        elif date_filter == 'past':\n            query = query.filter(Event.start_datetime < datetime.utcnow())\n        \n        # Paginate results\n        events_pagination = query.order_by(Event.start_datetime.desc()).paginate(\n            page=page, per_page=per_page, error_out=False\n        )\n        events = events_pagination.items\n        \n    except Exception as e:\n        app.logger.error(f'Error fetching events: {str(e)}')\n        events = []\n        events_pagination = None\n\n    return render_template('events.html', \n                         app_name=settings['app_name'],\n                         app_logo=settings['app_logo'],\n                         theme_color=settings['theme_color'],\n                         events=events, \n                         categories=categories,\n                         event_types=event_types,\n                         search_query=search_query,\n                         selected_status=status_filter,\n                         selected_category=category_filter,\n                         selected_type=type_filter,\n                         selected_date=date_filter,\n                         events_pagination=events_pagination)\n\n@app.route('/event_details/<int:event_id>')\n@login_required\ndef event_details(event_id):\n    \"\"\"Display detailed information about a specific event\"\"\"\n    try:\n        event = Event.query.get_or_404(event_id)\n        app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n        theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n        app_logo = AppSetting.get_setting('app_logo')\n\n        return render_template('event_details.html',\n                             app_name=app_name,\n                             app_logo=app_logo, \n                             theme_color=theme_color,\n                             event=event)\n    except Exception as e:\n        app.logger.error(f'Error loading event details: {str(e)}')\n        flash('Event not found or error loading details.', 'danger')\n        return redirect(url_for('events'))\n\n@app.route('/create_event', methods=['GET', 'POST'])\n@login_required\n@limiter.limit(\"20 per hour\")  # Rate limit event creation\ndef create_event():\n    app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n    theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n\n    # Get categories from database\n    try:\n        categories = EventCategory.query.order_by(EventCategory.name).all()\n    except Exception as e:\n        app.logger.error(f'Error fetching categories: {str(e)}')\n        categories = []\n\n    # Get event types from database\n    try:\n        event_types = EventType.query.order_by(EventType.name).all()\n    except Exception as e:\n        app.logger.error(f'Error fetching event types: {str(e)}')\n        event_types = []\n\n    if request.method == 'POST':\n        # Handle event creation\n        try:\n            # Get form data\n            title = request.form.get('title', '').strip()\n            description = request.form.get('description', '').strip()\n            event_type_id = request.form.get('event_type')\n            category_id = request.form.get('categories')\n            start_date = request.form.get('start_date')\n            end_date = request.form.get('end_date')\n            start_time = request.form.get('start_time')\n            end_time = request.form.get('end_time')\n            registration_deadline_date = request.form.get('registration_deadline_date')\n            registration_deadline_time = request.form.get('registration_deadline_time')\n            is_online = request.form.get('is_online') == 'on'\n            venue = request.form.get('venue', '').strip() if not is_online else None\n            governorate = request.form.get('governorate', '').strip() if not is_online else None\n            max_attendees = request.form.get('max_attendees')\n\n            # Handle attendees file upload (now required)\n            attendees_file = request.files.get('attendees_file')\n            attendees_filename = None\n            attendees_count = 0\n\n            # Check if attendees file is provided (required)\n            if not attendees_file or not attendees_file.filename:\n                log_security_event(\"FILE_UPLOAD_FAILED\", \"Missing attendees file\", user_id=current_user.id)\n                flash('Attendees list file is required. Please upload a CSV or Excel file with attendee details.', 'danger')\n                app_logo = AppSetting.get_setting('app_logo')\n                return render_template('create_event.html', \n                                     app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                     categories=categories, event_types=event_types, \n                                     governorates=egyptian_governorates, edit_mode=False)\n\n            if attendees_file and attendees_file.filename:\n                # Validate file size first\n                size_valid, size_message = validate_file_size(attendees_file, max_size_mb=5)\n                if not size_valid:\n                    log_security_event(\"FILE_UPLOAD_FAILED\", f\"Attendees file too large: {size_message}\", user_id=current_user.id)\n                    flash(size_message, 'danger')\n                    app_logo = AppSetting.get_setting('app_logo')\n                    return render_template('create_event.html', \n                                         app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                         categories=categories, event_types=event_types, \n                                         governorates=egyptian_governorates, edit_mode=False)\n\n                # Validate file type (CSV, Excel)\n                allowed_extensions = {'csv', 'xlsx', 'xls'}\n                file_ext = attendees_file.filename.rsplit('.', 1)[1].lower() if '.' in attendees_file.filename else ''\n                if file_ext not in allowed_extensions:\n                    log_security_event(\"FILE_UPLOAD_FAILED\", f\"Invalid attendees file type: {file_ext}\", user_id=current_user.id)\n                    flash('Attendees file must be CSV or Excel format', 'danger')\n                    app_logo = AppSetting.get_setting('app_logo')\n                    return render_template('create_event.html', \n                                         app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                         categories=categories, event_types=event_types, \n                                         governorates=egyptian_governorates, edit_mode=False)\n\n                # Save the file with error handling\n                try:\n                    upload_folder = os.path.join(app.static_folder or 'static', 'uploads', 'attendees')\n                    os.makedirs(upload_folder, exist_ok=True)\n                    attendees_filename = f\"attendees_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{attendees_file.filename}\"\n                    file_path = os.path.join(upload_folder, attendees_filename)\n                    attendees_file.save(file_path)\n                except OSError as e:\n                    app.logger.error(f'File save error: {str(e)}')\n                    flash('Error saving attendees file. Please try again.', 'danger')\n                    app_logo = AppSetting.get_setting('app_logo')\n                    return render_template('create_event.html', \n                                         app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                         categories=categories, event_types=event_types, \n                                         governorates=egyptian_governorates, edit_mode=False)\n\n                # Process and validate the attendees file\n                try:\n                    if file_ext == 'csv':\n                        df = pd.read_csv(file_path)\n                    else:  # xlsx or xls\n                        df = pd.read_excel(file_path)\n\n                    # Flexible validation - just check if file has data\n                    if df.empty:\n                        flash('Attendees file appears to be empty', 'danger')\n                        os.remove(file_path)  # Clean up the uploaded file\n                        app_logo = AppSetting.get_setting('app_logo')\n                        return render_template('create_event.html', \n                                             app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                             categories=categories, event_types=event_types, \n                                             governorates=egyptian_governorates, edit_mode=False)\n\n                    # Count valid attendees (rows with non-null values in key columns)\n                    # Look for columns that might contain names or emails\n                    name_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['name', 'participant', 'attendee'])]\n                    email_cols = [col for col in df.columns if 'email' in col.lower() or 'mail' in col.lower()]\n\n                    if name_cols:\n                        attendees_count = len(df.dropna(subset=name_cols[:1]))  # Use first name column\n                    else:\n                        attendees_count = len(df.dropna())  # Count all non-empty rows\n\n                    app.logger.info(f'Processed attendees file with {attendees_count} attendees from {len(df)} total rows')\n                    app.logger.info(f'File columns: {list(df.columns)}')\n\n                except Exception as e:\n                    app.logger.error(f'Error processing attendees file: {str(e)}')\n                    flash('Error processing attendees file. Please check the format and try again.', 'danger')\n                    if os.path.exists(file_path):\n                        os.remove(file_path)  # Clean up the uploaded file\n                    app_logo = AppSetting.get_setting('app_logo')\n                    return render_template('create_event.html', \n                                         app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                         categories=categories, event_types=event_types, \n                                         governorates=egyptian_governorates, edit_mode=False)\n\n            # Basic validation\n            app.logger.info(f'Form data received - Title: \"{title}\", Description: \"{description}\", Start Date: \"{start_date}\"')\n\n            validation_errors = []\n\n            if not title:\n                validation_errors.append('Event title is required')\n            if not description:\n                validation_errors.append('Event description is required')\n            if not start_date:\n                validation_errors.append('Start date is required')\n            if not end_date:\n                validation_errors.append('End date is required')\n            if not end_time:\n                validation_errors.append('End time is required')\n            # Validation for new required fields\n            venue = request.form.get('venue', '').strip()\n            service_request = request.form.get('service_request', '').strip()\n            employee_code = request.form.get('employee_code', '').strip()\n            \n            if not is_online and not venue:\n                validation_errors.append('Venue name is required for offline events')\n            if not service_request:\n                validation_errors.append('Service Request ID is required')\n            if not employee_code:\n                validation_errors.append('Employee Code is required')\n            \n            if not registration_deadline_date:\n                validation_errors.append('Registration deadline date is required')\n            if not registration_deadline_time:\n                validation_errors.append('Registration deadline time is required')\n            if not is_online and not governorate:\n                validation_errors.append('Governorate is required for offline events')\n\n            if validation_errors:\n                for error in validation_errors:\n                    flash(error, 'danger')\n                app_logo = AppSetting.get_setting('app_logo')\n                return render_template('create_event.html', \n                                     app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                     categories=categories, event_types=event_types, \n                                     governorates=egyptian_governorates, edit_mode=False)\n\n            # Combine date and time for datetime fields with error handling\n            start_datetime = None\n            end_datetime = None\n            registration_deadline = None\n\n            try:\n                if start_date:\n                    if start_time:\n                        start_datetime = datetime.strptime(f\"{start_date} {start_time}\", \"%Y-%m-%d %H:%M\")\n                    else:\n                        start_datetime = datetime.strptime(start_date, \"%Y-%m-%d\")\n\n                if end_date:\n                    if end_time:\n                        end_datetime = datetime.strptime(f\"{end_date} {end_time}\", \"%Y-%m-%d %H:%M\")\n                    else:\n                        end_datetime = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n                if registration_deadline_date and registration_deadline_time:\n                    registration_deadline = datetime.strptime(f\"{registration_deadline_date} {registration_deadline_time}\", \"%Y-%m-%d %H:%M\")\n                elif registration_deadline_date:\n                    registration_deadline = datetime.strptime(registration_deadline_date, \"%Y-%m-%d\")\n                else:\n                    # Default to start date if not provided (fallback)\n                    registration_deadline = start_datetime\n\n                # Validate datetime logic\n                if start_datetime and end_datetime and end_datetime <= start_datetime:\n                    flash('End date must be after start date', 'danger')\n                    app_logo = AppSetting.get_setting('app_logo')\n                    return render_template('create_event.html', \n                                         app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                         categories=categories, event_types=event_types, \n                                         governorates=egyptian_governorates, edit_mode=False)\n\n                # Update validation: registration deadline can now be after event end date (2 days after)\n                # Remove the old validation that required registration deadline to be before start date\n                pass\n\n            except ValueError as e:\n                flash(f'Invalid date/time format: {str(e)}', 'danger')\n                app_logo = AppSetting.get_setting('app_logo')\n                return render_template('create_event.html', \n                                     app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                     categories=categories, event_types=event_types, \n                                     governorates=egyptian_governorates, edit_mode=False)\n\n            # Handle optional image upload\n            image_filename = None\n            event_image = request.files.get('event_image')\n\n            if event_image and event_image.filename:\n                # Validate image file\n                allowed_extensions = {'png', 'jpg', 'jpeg', 'gif'}\n                max_file_size = 5 * 1024 * 1024  # 5MB limit\n\n                # Check file size\n                event_image.seek(0, 2)  # Seek to end\n                file_size = event_image.tell()\n                event_image.seek(0)  # Reset to beginning\n\n                if file_size > max_file_size:\n                    flash('Image file too large. Maximum size is 5MB.', 'danger')\n                    app_logo = AppSetting.get_setting('app_logo')\n                    return render_template('create_event.html', \n                                         app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                         categories=categories, event_types=event_types, \n                                         governorates=egyptian_governorates, edit_mode=False)\n\n                if '.' in event_image.filename:\n                    file_ext = event_image.filename.rsplit('.', 1)[1].lower()\n                    if file_ext in allowed_extensions:\n                        # Create uploads directory if it doesn't exist\n                        upload_folder = os.path.join(app.static_folder or 'static', 'uploads')\n                        os.makedirs(upload_folder, exist_ok=True)\n\n                        # Generate unique filename with secure filename\n                        from werkzeug.utils import secure_filename\n                        secure_name = secure_filename(event_image.filename)\n                        image_filename = f\"event_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{secure_name}\"\n                        image_path = os.path.join(upload_folder, image_filename)\n                        event_image.save(image_path)\n\n                        app.logger.info(f'Event image saved: {image_filename}')\n                    else:\n                        flash('Invalid image format. Please upload PNG, JPG, JPEG, or GIF files.', 'danger')\n                        app_logo = AppSetting.get_setting('app_logo')\n                        return render_template('create_event.html', \n                                             app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                             categories=categories, event_types=event_types, \n                                             governorates=egyptian_governorates, edit_mode=False)\n                else:\n                    flash('Invalid image filename. Please include a file extension.', 'danger')\n                    app_logo = AppSetting.get_setting('app_logo')\n                    return render_template('create_event.html', \n                                         app_name=app_name, app_logo=app_logo, theme_color=theme_color,\n                                         categories=categories, event_types=event_types, \n                                         governorates=egyptian_governorates, edit_mode=False)\n\n            # Create new event using SQLAlchemy ORM instead of raw SQL\n            # Set initial status based on user role\n            initial_status = 'active' if current_user.can_approve_events() else 'pending'\n\n            new_event = Event(\n                name=title,\n                description=description,\n                event_type_id=int(event_type_id) if event_type_id else None,\n                is_online=is_online,\n                start_datetime=start_datetime,\n                end_datetime=end_datetime,\n                registration_deadline=registration_deadline,\n                venue_id=None,  # We'll implement venue handling later\n                image_file=image_filename,  # Add image filename to event\n                governorate=governorate,\n                user_id=current_user.id,\n                status=initial_status\n            )\n\n            db.session.add(new_event)\n            db.session.flush()  # Flush to get the ID\n            event_id = new_event.id\n\n            # Handle category association if selected using SQLAlchemy ORM\n            if category_id:\n                try:\n                    category = EventCategory.query.get(int(category_id))\n                    if category:\n                        new_event.categories.append(category)\n                except Exception as e:\n                    app.logger.error(f'Error associating category: {str(e)}')\n\n            db.session.commit()\n            \n            # Invalidate caches after successful event creation\n            invalidate_dashboard_caches()\n\n            if current_user.can_approve_events():\n                success_message = f'Event \"{title}\" created successfully and is now active!'\n            else:\n                success_message = f'Event \"{title}\" created successfully and is pending approval from an admin or event manager.'\n\n            if attendees_count > 0:\n                success_message += f' Attendees file uploaded with {attendees_count} participants.'\n\n            app.logger.info(f'Event \"{title}\" created successfully with ID {event_id} by user {current_user.email}')\n            flash(success_message, 'success')\n            return redirect(url_for('events'))\n\n        except Exception as e:\n            db.session.rollback()\n            app.logger.error(f'Error creating event: {str(e)}')\n            import traceback\n            app.logger.error(f'Full traceback: {traceback.format_exc()}')\n            flash(f'Error creating event: {str(e)}. Please check all required fields.', 'danger')\n\n    # Use the global egyptian_governorates list\n\n    app_logo = AppSetting.get_setting('app_logo')\n    return render_template('create_event.html', \n                         app_name=app_name,\n                         app_logo=app_logo,\n                         theme_color=theme_color,\n                         categories=categories,\n                         event_types=event_types,\n                         governorates=egyptian_governorates,\n                         edit_mode=False)\n\n@app.route('/settings')\n@login_required\ndef settings():\n    # Get app settings from database\n    app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n    theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n\n    # Get categories from database using ORM\n    try:\n        categories = [{'id': cat.id, 'name': cat.name} for cat in EventCategory.query.order_by(EventCategory.name).all()]\n    except Exception as e:\n        app.logger.error(f'Error fetching categories: {str(e)}')\n        categories = []\n\n    # Get event types from database using ORM\n    try:\n        event_types = [{'id': et.id, 'name': et.name} for et in EventType.query.order_by(EventType.name).all()]\n    except Exception as e:\n        app.logger.error(f'Error fetching event types: {str(e)}')\n        event_types = []\n\n    # Get actual users from database\n    users = [{'id': u.id, 'email': u.email, 'role': u.role} for u in User.query.all()]\n\n    app_logo = AppSetting.get_setting('app_logo')\n    main_tagline = AppSetting.get_setting('main_tagline')\n    main_header = AppSetting.get_setting('main_header')\n    app_description = AppSetting.get_setting('app_description')\n    feature1_title = AppSetting.get_setting('feature1_title')\n    feature1_description = AppSetting.get_setting('feature1_description')\n    feature2_title = AppSetting.get_setting('feature2_title')\n    feature2_description = AppSetting.get_setting('feature2_description')\n    return render_template('settings.html',\n                         app_name=app_name,\n                         app_logo=app_logo,\n                         theme_color=theme_color,\n                         main_tagline=main_tagline,\n                         main_header=main_header,\n                         app_description=app_description,\n                         feature1_title=feature1_title,\n                         feature1_description=feature1_description,\n                         feature2_title=feature2_title,\n                         feature2_description=feature2_description,\n                         categories=categories,\n                         event_types=event_types,\n                         users=users)\n\n@app.route('/edit_event/<int:event_id>', methods=['GET', 'POST'])\n@login_required\ndef edit_event(event_id):\n    \"\"\"Edit an existing event\"\"\"\n    event = Event.query.get_or_404(event_id)\n\n    # Check if user has permission to edit this event\n    if not current_user.is_admin() and event.user_id != current_user.id:\n        flash('You do not have permission to edit this event.', 'danger')\n        return redirect(url_for('events'))\n\n    if request.method == 'POST':\n        # Handle form submission for event updates\n        try:\n            # Get form data\n            title = request.form.get('title', '').strip()\n            description = request.form.get('description', '').strip()\n            event_type_id = request.form.get('event_type')\n            category_id = request.form.get('categories')\n            is_online = 'is_online' in request.form\n            start_date = request.form.get('start_date')\n            start_time = request.form.get('start_time')\n            end_date = request.form.get('end_date')\n            end_time = request.form.get('end_time')\n            governorate = request.form.get('governorate')\n            registration_deadline_date = request.form.get('registration_deadline') # Added for editing\n\n            # Update event fields\n            if title:\n                event.name = title\n            if description:\n                event.description = description\n            if event_type_id:\n                event.event_type_id = int(event_type_id)\n            event.is_online = is_online\n            if governorate:\n                event.governorate = governorate\n\n            # Update datetime fields with validation\n            try:\n                if start_date:\n                    if start_time:\n                        new_start = datetime.strptime(f\"{start_date} {start_time}\", \"%Y-%m-%d %H:%M\")\n                    else:\n                        new_start = datetime.strptime(start_date, \"%Y-%m-%d\")\n                    event.start_datetime = new_start\n\n                if end_date:\n                    if end_time:\n                        new_end = datetime.strptime(f\"{end_date} {end_time}\", \"%Y-%m-%d %H:%M\")\n                    else:\n                        new_end = datetime.strptime(end_date, \"%Y-%m-%d\")\n                    event.end_datetime = new_end\n\n                # Update registration deadline (required field)\n                if registration_deadline_date:\n                    new_deadline = datetime.strptime(registration_deadline_date, \"%Y-%m-%d\")\n                    event.registration_deadline = new_deadline\n                elif event.start_datetime:\n                    # Fallback to start date if not provided\n                    event.registration_deadline = event.start_datetime\n\n                # Validate datetime logic\n                if event.start_datetime and event.end_datetime and event.end_datetime <= event.start_datetime:\n                    flash('End date must be after start date', 'danger')\n                    return redirect(url_for('edit_event', event_id=event.id))\n\n                if event.registration_deadline and event.start_datetime and event.registration_deadline > event.start_datetime:\n                    flash('Registration deadline must be before or on the event start date', 'danger')\n                    return redirect(url_for('edit_event', event_id=event.id))\n\n            except ValueError as e:\n                flash(f'Invalid date/time format: {str(e)}', 'danger')\n                return redirect(url_for('edit_event', event_id=event.id))\n\n\n            # Handle image upload\n            event_image = request.files.get('event_image')\n            if event_image and event_image.filename:\n                allowed_extensions = {'png', 'jpg', 'jpeg', 'gif'}\n                if '.' in event_image.filename:\n                    file_ext = event_image.filename.rsplit('.', 1)[1].lower()\n                    if file_ext in allowed_extensions:\n                        upload_folder = os.path.join(app.static_folder or 'static', 'uploads')\n                        os.makedirs(upload_folder, exist_ok=True)\n\n                        image_filename = f\"event_{datetime.now().strftime('%Y%m%d_%H%M%S')}.{file_ext}\"\n                        image_path = os.path.join(upload_folder, image_filename)\n                        event_image.save(image_path)\n\n                        event.image_file = image_filename\n                        app.logger.info(f'Event image updated: {image_filename}')\n\n            # Update category association\n            if category_id:\n                # Clear existing categories\n                event.categories.clear()\n                # Add new category\n                category = EventCategory.query.get(int(category_id))\n                if category:\n                    event.categories.append(category)\n\n            db.session.commit()\n            \n            # Invalidate caches after successful event update\n            invalidate_dashboard_caches()\n            \n            flash(f'Event \"{event.name}\" updated successfully!', 'success')\n            return redirect(url_for('events'))\n\n        except Exception as e:\n            db.session.rollback()\n            app.logger.error(f'Error updating event: {str(e)}')\n            flash('Error updating event. Please try again.', 'danger')\n\n    # Get app settings\n    app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n    theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n\n    # Get categories and event types from database using ORM\n    try:\n        categories = [{'id': cat.id, 'name': cat.name} for cat in EventCategory.query.order_by(EventCategory.name).all()]\n    except Exception as e:\n        app.logger.error(f'Error fetching categories: {str(e)}')\n        categories = []\n\n    try:\n        event_types = [{'id': et.id, 'name': et.name} for et in EventType.query.order_by(EventType.name).all()]\n    except Exception as e:\n        app.logger.error(f'Error fetching event types: {str(e)}')\n        event_types = []\n\n    return render_template('create_event.html', \n                         app_name=app_name,\n                         app_logo=None,\n                         theme_color=theme_color,\n                         categories=categories,\n                         event_types=event_types,\n                         governorates=egyptian_governorates,\n                         edit_mode=True,\n                         event=event)\n\n@app.route('/approve_event/<int:event_id>', methods=['POST'])\n@login_required\ndef approve_event(event_id):\n    \"\"\"Approve an event (admin and event manager only)\"\"\"\n    if not current_user.can_approve_events():\n        flash('Access denied. Admin or Event Manager privileges required.', 'danger')\n        return redirect(url_for('events'))\n\n    try:\n        event = Event.query.get_or_404(event_id)\n        event.status = 'active'\n        db.session.commit()\n        \n        # Invalidate caches after status change\n        invalidate_dashboard_caches()\n        \n        flash(f'Event \"{event.name}\" has been approved.', 'success')\n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error approving event {event_id}: {str(e)}')\n        flash('Error approving event. Please try again.', 'danger')\n\n    return redirect(url_for('events'))\n\n@app.route('/reject_event/<int:event_id>', methods=['POST'])\n@login_required\ndef reject_event(event_id):\n    \"\"\"Reject an event (admin and event manager only)\"\"\"\n    if not current_user.can_approve_events():\n        flash('Access denied. Admin or Event Manager privileges required.', 'danger')\n        return redirect(url_for('events'))\n\n    try:\n        event = Event.query.get_or_404(event_id)\n        event.status = 'declined'\n        db.session.commit()\n        \n        # Invalidate caches after status change\n        invalidate_dashboard_caches()\n        \n        flash(f'Event \"{event.name}\" has been declined.', 'warning')\n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error declining event {event_id}: {str(e)}')\n        flash('Error declining event. Please try again.', 'danger')\n\n    return redirect(url_for('events'))\n\n@app.route('/delete_event/<int:event_id>', methods=['POST'])\n@login_required\ndef delete_event(event_id):\n    \"\"\"Delete an event (admin only)\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Admin privileges required.', 'danger')\n        return redirect(url_for('events'))\n\n    try:\n        event = Event.query.get_or_404(event_id)\n        event_name = event.name\n        db.session.delete(event)\n        db.session.commit()\n        \n        # Invalidate caches after event deletion\n        invalidate_dashboard_caches()\n        \n        flash(f'Event \"{event_name}\" has been deleted successfully.', 'success')\n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error deleting event: {str(e)}')\n        flash('Error deleting event. Please try again.', 'danger')\n\n    return redirect(url_for('events'))\n\n@app.route('/export_events')\n@login_required\n@limiter.limit(\"5 per hour\")  # Limit exports due to resource intensity\ndef export_events():\n    \"\"\"Export events to CSV file with optimized streaming\"\"\"\n    \n    # Capture user permissions and fetch all events data in the request context\n    can_approve = current_user.can_approve_events()\n    user_id = current_user.id\n    user_email = current_user.email\n    \n    # Fetch all events data and convert to plain dictionaries within the request context\n    if can_approve:\n        events_query = Event.query.options(\n            db.joinedload(Event.event_type),\n            db.joinedload(Event.creator),\n            db.joinedload(Event.categories)\n        ).order_by(Event.created_at.desc()).all()\n    else:\n        events_query = Event.query.options(\n            db.joinedload(Event.event_type),\n            db.joinedload(Event.creator),\n            db.joinedload(Event.categories)\n        ).filter_by(user_id=user_id).order_by(Event.created_at.desc()).all()\n    \n    # Convert to plain dictionaries to avoid session issues\n    events_data = []\n    for event in events_query:\n        event_dict = {\n            'id': event.id,\n            'name': event.name,\n            'description': event.description or '',\n            'event_type': event.event_type.name if event.event_type else 'Not specified',\n            'is_online': event.is_online,\n            'start_datetime': event.start_datetime.strftime('%Y-%m-%d %H:%M') if event.start_datetime else '',\n            'end_datetime': event.end_datetime.strftime('%Y-%m-%d %H:%M') if event.end_datetime else '',\n            'governorate': event.governorate or '',\n            'categories': ', '.join([category.name for category in event.categories]) if event.categories else 'None',\n            'creator_email': event.creator.email if event.creator else '',\n            'created_at': event.created_at.strftime('%Y-%m-%d %H:%M') if event.created_at else '',\n            'status': event.status or 'Active'\n        }\n        events_data.append(event_dict)\n    \n    def generate_csv(events_list):\n        \"\"\"Generator function for streaming CSV export\"\"\"\n        output = io.StringIO()\n        fieldnames = [\n            'ID', 'Event Name', 'Description', 'Event Type', 'Is Online', \n            'Start Date', 'End Date', 'Governorate', 'Categories', \n            'Created By', 'Created At', 'Status'\n        ]\n        \n        writer = csv.DictWriter(output, fieldnames=fieldnames)\n        writer.writeheader()\n        yield output.getvalue()\n        output.seek(0)\n        output.truncate(0)\n        \n        # Process events in batches\n        batch_size = 50\n        total_events = len(events_list)\n        \n        for i in range(0, total_events, batch_size):\n            batch = events_list[i:i + batch_size]\n            \n            for event_data in batch:\n                writer.writerow({\n                    'ID': event_data['id'],\n                    'Event Name': event_data['name'],\n                    'Description': event_data['description'],\n                    'Event Type': event_data['event_type'],\n                    'Is Online': 'Yes' if event_data['is_online'] else 'No',\n                    'Start Date': event_data['start_datetime'],\n                    'End Date': event_data['end_datetime'],\n                    'Governorate': event_data['governorate'],\n                    'Categories': event_data['categories'],\n                    'Created By': event_data['creator_email'],\n                    'Created At': event_data['created_at'],\n                    'Status': event_data['status']\n                })\n                \n            yield output.getvalue()\n            output.seek(0)\n            output.truncate(0)\n    \n    try:\n        # Create streaming response\n        response = make_response(generate_csv(events_data))\n        response.headers['Content-Type'] = 'text/csv'\n        response.headers['Content-Disposition'] = f'attachment; filename=events_export_{datetime.now().strftime(\"%Y%m%d_%H%M%S\")}.csv'\n        \n        app.logger.info(f'Events export started by user {user_email}')\n        return response\n        \n    except Exception as e:\n        app.logger.error(f'Error exporting events: {str(e)}')\n        flash('Error exporting events. Please try again.', 'danger')\n        return redirect(url_for('events'))\n\n@app.route('/api/download/attendees-template')\n@login_required\ndef download_attendees_template():\n    \"\"\"Download CSV template for attendees upload\"\"\"\n\n    # Create CSV template content\n    csv_content = io.StringIO()\n    csv_writer = csv.writer(csv_content)\n\n    # Write header row\n    csv_writer.writerow(['Name', 'Email', 'Phone', 'Title', 'Company', 'Department', 'Special_Requirements'])\n\n    # Write sample rows\n    csv_writer.writerow(['Dr. Ahmed Hassan', 'ahmed.hassan@example.com', '+20 123 456 7890', 'Cardiologist', 'Cairo Medical Center', 'Cardiology', 'Vegetarian meal'])\n    csv_writer.writerow(['Dr. Sarah Mohamed', 'sarah.mohamed@example.com', '+20 987 654 3210', 'Neurologist', 'Alexandria Hospital', 'Neurology', ''])\n\n    # Create response\n    response = make_response(csv_content.getvalue())\n    response.headers['Content-Type'] = 'text/csv'\n    response.headers['Content-Disposition'] = 'attachment; filename=attendees_template.csv'\n\n    return response\n\n@app.route('/api/download/users-template')\n@login_required\ndef download_users_template():\n    \"\"\"Download Excel template for bulk user creation\"\"\"\n\n    # Create sample data for the template - Required columns first\n    sample_data = {\n        'Email': ['ahmed.hassan@example.com', 'sarah.mohamed@example.com', 'mohamed.ali@example.com'],\n        'Role': ['medical_rep', 'event_manager', 'admin'],\n        'Password': ['SecurePass123!', 'MyPassword456#', 'AdminPass789$'],\n        'Full Name': ['Dr. Ahmed Hassan', 'Dr. Sarah Mohamed', 'Dr. Mohamed Ali'],  # Optional field\n        'Department': ['Cardiology', 'Neurology', 'Administration'],\n        'Phone': ['+20 123 456 7890', '+20 987 654 3210', '+20 555 123 4567'],\n        'Employee ID': ['EMP001', 'EMP002', 'EMP003']\n    }\n\n    df = pd.DataFrame(sample_data)\n\n    # Create Excel file in memory\n    output = io.BytesIO()\n    with pd.ExcelWriter(output, engine='openpyxl') as writer:\n        df.to_excel(writer, index=False, sheet_name='Users')\n    output.seek(0)\n\n    # Create response\n    response = make_response(output.getvalue())\n    response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n    response.headers['Content-Disposition'] = 'attachment; filename=users_template.xlsx'\n\n    return response\n\n@app.route('/bulk-user-upload', methods=['GET', 'POST'])\n@login_required\n@limiter.limit(\"3 per hour\")  # Very restrictive for bulk operations\ndef bulk_user_upload():\n    \"\"\"Handle bulk user creation from Excel file\"\"\"\n    app_name = AppSetting.get_setting('app_name', 'PharmaEvents')\n    theme_color = AppSetting.get_setting('theme_color', '#0f6e84')\n\n    if request.method == 'POST':\n        users_file = request.files.get('users_file')\n\n        if not users_file or not users_file.filename:\n            flash('Please select a file to upload', 'danger')\n            return render_template('bulk_user_upload.html', \n                                 app_name=app_name, theme_color=theme_color)\n\n        # Validate file extension\n        allowed_extensions = {'xlsx', 'xls'}\n        file_ext = users_file.filename.rsplit('.', 1)[1].lower() if '.' in users_file.filename else ''\n\n        if file_ext not in allowed_extensions:\n            flash('Please upload an Excel file (.xlsx or .xls)', 'danger')\n            return render_template('bulk_user_upload.html', \n                                 app_name=app_name, theme_color=theme_color)\n\n        try:\n            # Read Excel file\n            df = pd.read_excel(users_file)\n\n            # Flexible column matching based on actual Excel file structure\n            df_columns = df.columns.tolist()\n            app.logger.info(f'Excel columns found: {df_columns}')\n\n            # Map the actual columns from the Excel file\n            email_col = None\n            password_col = None  \n            role_col = None\n\n            for col in df_columns:\n                col_lower = col.lower().strip()\n                if 'email' in col_lower:\n                    email_col = col\n                elif 'password' in col_lower:\n                    password_col = col\n                elif 'role' in col_lower:\n                    role_col = col\n\n            # Check if we have the required columns\n            missing_columns = []\n            if not email_col:\n                missing_columns.append('Email')\n            if not password_col:\n                missing_columns.append('Password')\n            if not role_col:\n                missing_columns.append('Role')\n\n            if missing_columns:\n                flash(f'Missing required columns: {\", \".join(missing_columns)}. Please download the template and use the correct format.', 'danger')\n                return render_template('bulk_user_upload.html', \n                                     app_name=app_name, theme_color=theme_color)\n\n            # Process users in batches for better performance\n            success_count = 0\n            error_count = 0\n            errors = []\n            batch_size = 50  # Process in batches of 50 users\n\n            # Pre-validate all data first\n            users_to_create = []\n            existing_emails = set()\n\n            # Get all existing emails in one query for efficiency\n            existing_users = db.session.query(User.email).all()\n            existing_emails = {email[0].lower() for email in existing_users}\n\n            # Validate all rows first\n            for index, row in df.iterrows():\n                try:\n                    row_num = int(index) if isinstance(index, (int, float)) else 0\n                    email = str(row[email_col]).strip().lower() if email_col and pd.notna(row[email_col]) else ''\n                    role = str(row[role_col]).strip().lower() if role_col and pd.notna(row[role_col]) else ''\n                    user_password = str(row[password_col]).strip() if password_col and pd.notna(row[password_col]) else None\n\n                    # Validate required fields\n                    if not email or not role or not user_password:\n                        errors.append(f'Row {row_num + 2}: Missing required fields (Email, Password, or Role)')\n                        error_count += 1\n                        continue\n\n                    # Normalize role names\n                    role_mapping = {\n                        'medical rep': 'medical_rep',\n                        'medical_rep': 'medical_rep', \n                        'event manager': 'event_manager',\n                        'event_manager': 'event_manager',\n                        'admin': 'admin'\n                    }\n\n                    normalized_role = role_mapping.get(role, role)\n                    valid_roles = ['admin', 'event_manager', 'medical_rep']\n\n                    if normalized_role not in valid_roles:\n                        errors.append(f'Row {row_num + 2}: Invalid role \"{role}\". Must be one of: admin, event_manager, medical_rep')\n                        error_count += 1\n                        continue\n\n                    # Check if user already exists\n                    if email in existing_emails:\n                        errors.append(f'Row {row_num + 2}: User with email \"{email}\" already exists')\n                        error_count += 1\n                        continue\n\n                    # Add to existing emails to catch duplicates within the file\n                    if email in [u['email'] for u in users_to_create]:\n                        errors.append(f'Row {row_num + 2}: Duplicate email \"{email}\" in file')\n                        error_count += 1\n                        continue\n\n                    users_to_create.append({\n                        'email': email,\n                        'role': normalized_role,\n                        'password': user_password\n                    })\n\n                except Exception as e:\n                    row_num = int(index) if isinstance(index, (int, float)) else 0\n                    errors.append(f'Row {row_num + 2}: {str(e)}')\n                    error_count += 1\n\n            # Create users in batches\n            try:\n                for i in range(0, len(users_to_create), batch_size):\n                    batch = users_to_create[i:i + batch_size]\n                    batch_success_count = 0\n\n                    try:\n                        for user_data in batch:\n                            new_user = User()\n                            new_user.email = user_data['email']\n                            new_user.role = user_data['role']\n                            new_user.set_password(user_data['password'])\n                            db.session.add(new_user)\n                            batch_success_count += 1\n\n                        # Commit each batch\n                        db.session.commit()\n                        success_count += batch_success_count\n                        app.logger.info(f'Processed batch {i//batch_size + 1}, created {len(batch)} users')\n                        \n                    except Exception as batch_error:\n                        db.session.rollback()\n                        app.logger.error(f'Error in batch {i//batch_size + 1}: {str(batch_error)}')\n                        errors.append(f'Batch {i//batch_size + 1}: Database error - {str(batch_error)}')\n                        error_count += len(batch)\n\n                # Flash success/error messages\n                if success_count > 0:\n                    flash(f'Successfully created {success_count} users!', 'success')\n\n                if error_count > 0:\n                    flash(f'Failed to create {error_count} users. See details below.', 'warning')\n                    for error in errors[:10]:  # Show first 10 errors\n                        flash(error, 'danger')\n                    if len(errors) > 10:\n                        flash(f'... and {len(errors) - 10} more errors', 'danger')\n\n            except Exception as e:\n                db.session.rollback()\n                app.logger.error(f'Error committing bulk user creation: {str(e)}')\n                flash(f'Database error: {str(e)}', 'danger')\n\n        except Exception as e:\n            db.session.rollback()\n            app.logger.error(f'Error processing bulk user upload: {str(e)}')\n            flash(f'Error processing file: {str(e)}', 'danger')\n\n    return render_template('bulk_user_upload.html', \n                         app_name=app_name, theme_color=theme_color)\n\ndef get_filtered_dashboard_stats(user_id, is_admin, search_query='', category_filter='all', type_filter='all', date_filter='all'):\n    \"\"\"Get dashboard statistics with filters applied\"\"\"\n    from sqlalchemy import func\n    \n    now = datetime.now()\n    \n    # Build base query\n    if is_admin:\n        query = Event.query\n    else:\n        query = Event.query.filter_by(user_id=user_id)\n    \n    # Apply search filter\n    if search_query:\n        query = query.filter(\n            db.or_(\n                Event.name.ilike(f'%{search_query}%'),\n                Event.description.ilike(f'%{search_query}%'),\n                Event.location.ilike(f'%{search_query}%')\n            )\n        )\n    \n    # Apply category filter\n    if category_filter != 'all':\n        try:\n            category_id = int(category_filter)\n            query = query.filter(Event.categories.any(EventCategory.id == category_id))\n        except (ValueError, TypeError):\n            pass\n    \n    # Apply event type filter\n    if type_filter != 'all':\n        try:\n            type_id = int(type_filter)\n            query = query.filter_by(event_type_id=type_id)\n        except (ValueError, TypeError):\n            pass\n    \n    # Apply date filter\n    if date_filter == 'upcoming':\n        query = query.filter(Event.start_datetime > now)\n    elif date_filter == 'past':\n        query = query.filter(Event.start_datetime < now)\n    elif date_filter == 'this_month':\n        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n        end_of_month = (start_of_month + timedelta(days=32)).replace(day=1) - timedelta(seconds=1)\n        query = query.filter(Event.start_datetime >= start_of_month, Event.start_datetime <= end_of_month)\n    elif date_filter == 'last_month':\n        first_of_this_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n        first_of_last_month = (first_of_this_month - timedelta(days=1)).replace(day=1)\n        last_of_last_month = first_of_this_month - timedelta(seconds=1)\n        query = query.filter(Event.start_datetime >= first_of_last_month, Event.start_datetime <= last_of_last_month)\n    \n    # Calculate statistics\n    total_events = query.count()\n    upcoming_events = query.filter(Event.start_datetime > now).count()\n    online_events = query.filter_by(is_online=True).count()\n    offline_events = query.filter_by(is_online=False).count()\n    pending_events = query.filter_by(status='pending').count() if is_admin else 0\n    \n    return {\n        'total_events': total_events,\n        'upcoming_events': upcoming_events,\n        'online_events': online_events,\n        'offline_events': offline_events,\n        'pending_events': pending_events\n    }\n\ndef get_filtered_category_data(user_id, is_admin, search_query='', category_filter='all', type_filter='all', date_filter='all'):\n    \"\"\"Get filtered category data for charts\"\"\"\n    from sqlalchemy import func\n    \n    # Build base query\n    if is_admin:\n        query = db.session.query(EventCategory.name, func.count(Event.id).label('count')).join(\n            event_categories, EventCategory.id == event_categories.c.category_id\n        ).join(Event, Event.id == event_categories.c.event_id)\n    else:\n        query = db.session.query(EventCategory.name, func.count(Event.id).label('count')).join(\n            event_categories, EventCategory.id == event_categories.c.category_id\n        ).join(Event, Event.id == event_categories.c.event_id).filter(Event.user_id == user_id)\n    \n    # Apply filters (similar logic as dashboard stats)\n    query = apply_chart_filters(query, search_query, category_filter, type_filter, date_filter)\n    \n    results = query.group_by(EventCategory.id, EventCategory.name).all()\n    return [{'name': name, 'count': count} for name, count in results]\n\ndef get_filtered_type_data(user_id, is_admin, search_query='', category_filter='all', type_filter='all', date_filter='all'):\n    \"\"\"Get filtered event type data for charts\"\"\"\n    from sqlalchemy import func\n    \n    # Build base query\n    if is_admin:\n        query = db.session.query(EventType.name, func.count(Event.id).label('count')).join(\n            Event, Event.event_type_id == EventType.id\n        )\n    else:\n        query = db.session.query(EventType.name, func.count(Event.id).label('count')).join(\n            Event, Event.event_type_id == EventType.id\n        ).filter(Event.user_id == user_id)\n    \n    # Apply filters\n    query = apply_chart_filters(query, search_query, category_filter, type_filter, date_filter)\n    \n    results = query.group_by(EventType.id, EventType.name).all()\n    return [{'name': name, 'count': count} for name, count in results]\n\ndef get_filtered_monthly_data(user_id, is_admin, search_query='', category_filter='all', type_filter='all', date_filter='all'):\n    \"\"\"Get filtered monthly data for charts\"\"\"\n    from sqlalchemy import func, extract\n    current_year = datetime.now().year\n    \n    # Build base query\n    if is_admin:\n        query = db.session.query(\n            extract('month', Event.start_datetime).label('month'),\n            func.count(Event.id).label('count')\n        ).filter(extract('year', Event.start_datetime) == current_year)\n    else:\n        query = db.session.query(\n            extract('month', Event.start_datetime).label('month'),\n            func.count(Event.id).label('count')\n        ).filter(\n            Event.user_id == user_id,\n            extract('year', Event.start_datetime) == current_year\n        )\n    \n    # Apply filters\n    query = apply_chart_filters(query, search_query, category_filter, type_filter, date_filter)\n    \n    results = query.group_by(extract('month', Event.start_datetime)).all()\n    \n    # Initialize all months with 0\n    monthly_counts = [0] * 12\n    for month, count in results:\n        if month:\n            monthly_counts[int(month) - 1] = count\n    \n    return {\n        'labels': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'data': monthly_counts\n    }\n\ndef get_filtered_requester_data(user_id, is_admin, search_query='', category_filter='all', type_filter='all', date_filter='all'):\n    \"\"\"Get filtered requester data for charts\"\"\"\n    from sqlalchemy import func\n    \n    # Build base query\n    if is_admin:\n        query = db.session.query(\n            User.email,\n            func.count(Event.id).label('event_count')\n        ).join(Event, User.id == Event.user_id)\n    else:\n        # For regular users, only show their own data\n        query = db.session.query(\n            User.email,\n            func.count(Event.id).label('event_count')\n        ).join(Event, User.id == Event.user_id).filter(Event.user_id == user_id)\n    \n    # Apply filters\n    query = apply_chart_filters(query, search_query, category_filter, type_filter, date_filter)\n    \n    results = query.group_by(User.id, User.email).all()\n    return [{'name': email, 'count': count} for email, count in results]\n\ndef apply_chart_filters(query, search_query='', category_filter='all', type_filter='all', date_filter='all'):\n    \"\"\"Apply common filters to chart queries\"\"\"\n    now = datetime.now()\n    \n    # Apply search filter\n    if search_query:\n        query = query.filter(\n            db.or_(\n                Event.name.ilike(f'%{search_query}%'),\n                Event.description.ilike(f'%{search_query}%'),\n                Event.location.ilike(f'%{search_query}%')\n            )\n        )\n    \n    # Apply category filter\n    if category_filter != 'all':\n        try:\n            category_id = int(category_filter)\n            query = query.filter(Event.categories.any(EventCategory.id == category_id))\n        except (ValueError, TypeError):\n            pass\n    \n    # Apply event type filter\n    if type_filter != 'all':\n        try:\n            type_id = int(type_filter)\n            query = query.filter(Event.event_type_id == type_id)\n        except (ValueError, TypeError):\n            pass\n    \n    # Apply date filter\n    if date_filter == 'upcoming':\n        query = query.filter(Event.start_datetime > now)\n    elif date_filter == 'past':\n        query = query.filter(Event.start_datetime < now)\n    elif date_filter == 'this_month':\n        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n        end_of_month = (start_of_month + timedelta(days=32)).replace(day=1) - timedelta(seconds=1)\n        query = query.filter(Event.start_datetime >= start_of_month, Event.start_datetime <= end_of_month)\n    elif date_filter == 'last_month':\n        first_of_this_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n        first_of_last_month = (first_of_this_month - timedelta(days=1)).replace(day=1)\n        last_of_last_month = first_of_this_month - timedelta(seconds=1)\n        query = query.filter(Event.start_datetime >= first_of_last_month, Event.start_datetime <= last_of_last_month)\n    \n    return query\n\n@app.route('/api/dashboard/stats')\n@login_required\ndef api_dashboard_stats():\n    from flask import jsonify\n    \n    try:\n        # Use cached stats for better performance\n        stats = get_dashboard_stats_cached(\n            user_id=current_user.id,\n            is_admin=current_user.can_approve_events()\n        )\n        return jsonify(stats)\n    except Exception as e:\n        app.logger.error(f'Error getting dashboard stats: {str(e)}')\n        return jsonify({\n            'total_events': 0,\n            'upcoming_events': 0,\n            'online_events': 0,\n            'offline_events': 0,\n            'pending_events': 0,\n            'completed_events': 0\n        })\n\n@app.route('/api/dashboard/categories')\n@login_required\ndef api_category_data():\n    from flask import jsonify\n    try:\n        # Get filter parameters from URL\n        search_query = request.args.get('search', '').strip()\n        category_filter = request.args.get('category', 'all')\n        type_filter = request.args.get('type', 'all')\n        date_filter = request.args.get('date', 'all')\n        \n        # Use filtered data instead of cached data\n        categories_data = get_filtered_category_data(\n            user_id=current_user.id,\n            is_admin=current_user.can_approve_events(),\n            search_query=search_query,\n            category_filter=category_filter,\n            type_filter=type_filter,\n            date_filter=date_filter\n        )\n        return jsonify(categories_data)\n    except Exception as e:\n        app.logger.error(f'Error getting category data: {str(e)}')\n        return jsonify([])\n\n@app.route('/api/dashboard/monthly')\n@login_required  \ndef api_monthly_data():\n    from flask import jsonify\n    \n    try:\n        # Get filter parameters from URL\n        search_query = request.args.get('search', '').strip()\n        category_filter = request.args.get('category', 'all')\n        type_filter = request.args.get('type', 'all')\n        date_filter = request.args.get('date', 'all')\n        \n        # Use filtered monthly data\n        monthly_data = get_filtered_monthly_data(\n            user_id=current_user.id,\n            is_admin=current_user.can_approve_events(),\n            search_query=search_query,\n            category_filter=category_filter,\n            type_filter=type_filter,\n            date_filter=date_filter\n        )\n        return jsonify(monthly_data)\n    except Exception as e:\n        app.logger.error(f'Error getting monthly data: {str(e)}')\n        return jsonify({\n            'labels': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            'data': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        })\n\n@cache.memoize(timeout=600)  # Cache for 10 minutes\ndef get_event_types_data_cached(user_id, is_admin):\n    \"\"\"Get cached event types distribution\"\"\"\n    from sqlalchemy import func\n    \n    if is_admin:\n        result = db.session.query(\n            EventType.name,\n            func.count(Event.id).label('count')\n        ).outerjoin(Event, EventType.id == Event.event_type_id).group_by(\n            EventType.id, EventType.name\n        ).having(func.count(Event.id) > 0).order_by(func.count(Event.id).desc()).all()\n    else:\n        result = db.session.query(\n            EventType.name,\n            func.count(Event.id).label('count')\n        ).outerjoin(Event, EventType.id == Event.event_type_id).filter(\n            Event.user_id == user_id\n        ).group_by(\n            EventType.id, EventType.name\n        ).having(func.count(Event.id) > 0).order_by(func.count(Event.id).desc()).all()\n    \n    event_types_data = [{'name': row[0], 'count': row[1]} for row in result]\n    \n    # If no events, show online vs offline distribution\n    if not event_types_data:\n        if is_admin:\n            online_count = Event.query.filter_by(is_online=True).count()\n            offline_count = Event.query.filter_by(is_online=False).count()\n        else:\n            online_count = Event.query.filter_by(user_id=user_id, is_online=True).count()\n            offline_count = Event.query.filter_by(user_id=user_id, is_online=False).count()\n            \n        if online_count > 0 or offline_count > 0:\n            event_types_data = [\n                {'name': 'Online Events', 'count': online_count},\n                {'name': 'Offline Events', 'count': offline_count}\n            ]\n    \n    return event_types_data\n\n@app.route('/api/dashboard/event-types')\n@login_required\ndef api_event_types_data():\n    from flask import jsonify\n    try:\n        # Get filter parameters from URL\n        search_query = request.args.get('search', '').strip()\n        category_filter = request.args.get('category', 'all')\n        type_filter = request.args.get('type', 'all')\n        date_filter = request.args.get('date', 'all')\n        \n        # Use filtered data instead of cached data\n        event_types_data = get_filtered_type_data(\n            user_id=current_user.id,\n            is_admin=current_user.can_approve_events(),\n            search_query=search_query,\n            category_filter=category_filter,\n            type_filter=type_filter,\n            date_filter=date_filter\n        )\n        return jsonify(event_types_data)\n    except Exception as e:\n        app.logger.error(f'Error getting event types data: {str(e)}')\n        return jsonify([])\n\n# Cache invalidation helper functions\ndef invalidate_dashboard_caches():\n    \"\"\"Invalidate all dashboard-related caches when data changes\"\"\"\n    try:\n        cache.delete_memoized(get_dashboard_stats_cached)\n        cache.delete_memoized(get_category_data_cached)\n        cache.delete_memoized(get_monthly_data_cached)\n        cache.delete_memoized(get_event_types_data_cached)\n        cache.delete_memoized(get_requester_data_cached)\n        app.logger.info('Dashboard caches invalidated')\n    except Exception as e:\n        app.logger.error(f'Error invalidating caches: {str(e)}')\n\ndef create_database_indexes():\n    \"\"\"Create additional database indexes for performance optimization\"\"\"\n    try:\n        # The indexes are already defined in the Event model's __table_args__\n        # This function is for future manual index creation if needed\n        app.logger.info('Database indexes are defined in model schema')\n        \n        # Additional indexes can be created here if needed\n        # Example: db.session.execute('CREATE INDEX IF NOT EXISTS idx_custom ON table (column)')\n        \n    except Exception as e:\n        app.logger.error(f'Error creating database indexes: {str(e)}')\n\n@cache.memoize(timeout=600)  # Cache for 10 minutes\ndef get_requester_data_cached(user_id, is_admin):\n    \"\"\"Get cached requester distribution data\"\"\"\n    from sqlalchemy import func\n    \n    if is_admin:\n        results = db.session.query(\n            User.email,\n            func.count(Event.id).label('event_count')\n        ).join(Event, User.id == Event.user_id).group_by(User.id, User.email).all()\n    else:\n        results = db.session.query(\n            User.email,\n            func.count(Event.id).label('event_count')\n        ).join(Event, User.id == Event.user_id).filter(User.id == user_id).group_by(User.id, User.email).all()\n    \n    requester_data = [{'name': email, 'count': count} for email, count in results]\n    requester_data.sort(key=lambda x: x['count'], reverse=True)\n    \n    return requester_data\n\n@app.route('/api/dashboard/requesters')\n@login_required\ndef api_requester_data():\n    from flask import jsonify\n    try:\n        # Use cached requester data for better performance\n        requester_data = get_requester_data_cached(\n            user_id=current_user.id,\n            is_admin=current_user.can_approve_events()\n        )\n        return jsonify(requester_data)\n    except Exception as e:\n        app.logger.error(f'Error getting requester data: {str(e)}')\n        return jsonify([])\n\n\n\n@app.route('/api/settings/theme', methods=['POST'])\n@login_required\n@limiter.limit(\"30 per minute\")\ndef api_update_theme():\n    from flask import jsonify, request\n    import re\n    try:\n        app.logger.info(f'Theme update request: authenticated={current_user.is_authenticated}')\n\n        # Check if user is authenticated\n        if not current_user.is_authenticated:\n            app.logger.warning('Unauthenticated theme update attempt')\n            return jsonify({'error': 'Not authenticated', 'debug': 'User not logged in'}), 401\n\n        data = request.get_json()\n        app.logger.info(f'Theme update data: {data}')\n\n        if not data or 'theme_color' not in data:\n            return jsonify({'error': 'Theme color is required'}), 400\n\n        theme_color = data['theme_color'].strip()\n        \n        # Validate hex color format\n        if not re.match(r'^#[0-9A-Fa-f]{6}$', theme_color):\n            return jsonify({'error': 'Invalid color format. Use hex format like #FF0000'}), 400\n            \n        # Save to database\n        AppSetting.set_setting('theme_color', theme_color)\n        app.logger.info(f'Theme color saved: {theme_color}')\n        # Don't flash message for API calls - JavaScript handles notifications\n        return jsonify({'success': True, 'theme_color': theme_color})\n    except Exception as e:\n        app.logger.error(f'Error in api_update_theme: {str(e)}')\n        return jsonify({'error': str(e), 'debug': 'Server error occurred'}), 500\n\n@app.route('/api/settings/app', methods=['POST'])\n@login_required\ndef api_update_app_settings():\n    from flask import jsonify, request\n    try:\n        # Check if user is authenticated\n        if not current_user.is_authenticated:\n            return jsonify({'error': 'Not authenticated'}), 401\n\n        data = request.get_json()\n        if not data:\n            return jsonify({'error': 'No data provided'}), 400\n\n        # Save to database\n        if 'name' in data:\n            AppSetting.set_setting('app_name', data['name'])\n            # Don't flash message for API calls - JavaScript handles notifications\n        return jsonify({'success': True})\n    except Exception as e:\n        app.logger.error(f'Error in api_update_app_settings: {str(e)}')\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/settings/login-content', methods=['POST'])\n@login_required\ndef api_update_login_content():\n    from flask import jsonify, request\n    try:\n        data = request.get_json()\n        if not data:\n            return jsonify({'error': 'No data provided'}), 400\n\n        # Save each field to database\n        if 'main_tagline' in data:\n            AppSetting.set_setting('main_tagline', data['main_tagline'])\n        if 'main_header' in data:\n            AppSetting.set_setting('main_header', data['main_header'])\n        if 'app_description' in data:\n            AppSetting.set_setting('app_description', data['app_description'])\n        if 'feature1_title' in data:\n            AppSetting.set_setting('feature1_title', data['feature1_title'])\n        if 'feature1_description' in data:\n            AppSetting.set_setting('feature1_description', data['feature1_description'])\n        if 'feature2_title' in data:\n            AppSetting.set_setting('feature2_title', data['feature2_title'])\n        if 'feature2_description' in data:\n            AppSetting.set_setting('feature2_description', data['feature2_description'])\n\n        return jsonify({'success': True})\n    except Exception as e:\n        app.logger.error(f'Error updating login content: {str(e)}')\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/static/uploads/<filename>')\ndef uploaded_file(filename):\n    # Secure file serving route for uploaded files\n    from flask import send_from_directory\n    from werkzeug.utils import secure_filename\n    import os\n    \n    # Validate filename to prevent directory traversal\n    secure_name = secure_filename(filename)\n    if secure_name != filename or '..' in filename or filename.startswith('/'):\n        return \"Invalid filename\", 400\n    \n    # Check if file exists and is in uploads directory\n    upload_path = os.path.join(app.static_folder or 'static', 'uploads')\n    file_path = os.path.join(upload_path, secure_name)\n    \n    if not os.path.exists(file_path) or not os.path.commonpath([upload_path, file_path]) == upload_path:\n        return \"File not found\", 404\n        \n    return send_from_directory('static/uploads', secure_name)\n\n@app.route('/api/settings/logo', methods=['POST'])\n@login_required\ndef api_upload_logo():\n    from flask import jsonify, request, make_response\n    try:\n        if 'logo' not in request.files:\n            return jsonify({'error': 'No logo file provided'}), 400\n\n        logo_file = request.files['logo']\n        if logo_file.filename == '':\n            return jsonify({'error': 'No file selected'}), 400\n\n        # Validate file type\n        allowed_extensions = {'png', 'jpg', 'jpeg', 'svg'}\n        if logo_file.filename and '.' in logo_file.filename:\n            file_ext = logo_file.filename.rsplit('.', 1)[1].lower()\n        else:\n            file_ext = ''\n\n        if file_ext not in allowed_extensions:\n            return jsonify({'error': 'Invalid file type. Please upload PNG, JPG, JPEG, or SVG files only.'}), 400\n\n        # Create uploads directory if it doesn't exist\n        upload_folder = os.path.join(app.static_folder or 'static', 'uploads')\n        os.makedirs(upload_folder, exist_ok=True)\n\n        # Generate unique filename\n        logo_filename = f\"logo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.{file_ext}\"\n        logo_path = os.path.join(upload_folder, logo_filename)\n\n        # Save the file\n        logo_file.save(logo_path)\n\n        # Store logo path in settings\n        logo_url = f\"/static/uploads/{logo_filename}\"\n        AppSetting.set_setting('app_logo', logo_url)\n\n        app.logger.info(f'Logo uploaded successfully: {logo_url}')\n        return jsonify({'success': True, 'logo_url': logo_url, 'message': 'Logo uploaded successfully!'})\n\n    except Exception as e:\n        app.logger.error(f'Error uploading logo: {str(e)}')\n        return jsonify({'error': f'Failed to upload logo: {str(e)}'}), 500\n\n@app.route('/api/settings/logo', methods=['DELETE'])\n@login_required\ndef api_remove_logo():\n    from flask import jsonify\n    try:\n        # Get current logo to remove the file\n        current_logo = AppSetting.get_setting('app_logo')\n        \n        # Remove logo setting from database\n        AppSetting.set_setting('app_logo', None)\n        \n        # Try to remove the physical file if it exists\n        if current_logo and current_logo.startswith('/static/uploads/'):\n            try:\n                file_path = os.path.join(app.static_folder or 'static', 'uploads', \n                                       current_logo.split('/')[-1])\n                if os.path.exists(file_path):\n                    os.remove(file_path)\n                    app.logger.info(f'Removed logo file: {file_path}')\n            except Exception as file_error:\n                app.logger.warning(f'Could not remove logo file: {str(file_error)}')\n        \n        app.logger.info('Logo removed successfully')\n        return jsonify({'success': True, 'message': 'Logo removed successfully!'})\n        \n    except Exception as e:\n        app.logger.error(f'Error removing logo: {str(e)}')\n        return jsonify({'error': f'Failed to remove logo: {str(e)}'}), 500\n\n@app.route('/api/categories', methods=['POST'])\n@login_required\ndef api_add_category():\n    from flask import jsonify, request\n    try:\n        category_name = request.form.get('category_name', '').strip()\n        if not category_name:\n            return jsonify({'error': 'Category name is required'}), 400\n\n        # Check if category already exists\n        existing_category = EventCategory.query.filter_by(name=category_name).first()\n        if existing_category:\n            return jsonify({'error': 'Category already exists'}), 400\n\n        # Create new category\n        new_category = EventCategory(name=category_name)\n        db.session.add(new_category)\n        db.session.commit()\n        \n        # Invalidate caches\n        invalidate_dashboard_caches()\n        \n        app.logger.info(f'Category \"{category_name}\" added by user {current_user.id}')\n        return jsonify({'success': True, 'id': new_category.id, 'name': new_category.name})\n        \n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error adding category: {str(e)}')\n        return jsonify({'error': 'Database error occurred'}), 500\n\n@app.route('/api/categories/<int:category_id>', methods=['DELETE'])\n@login_required\ndef api_delete_category(category_id):\n    from flask import jsonify\n    try:\n        category = EventCategory.query.get_or_404(category_id)\n        \n        # Check if category is used by any events\n        events_using_category = Event.query.filter(Event.categories.contains(category)).count()\n        if events_using_category > 0:\n            return jsonify({'error': f'Cannot delete category. It is used by {events_using_category} event(s).'}), 400\n        \n        category_name = category.name\n        db.session.delete(category)\n        db.session.commit()\n        \n        # Invalidate caches\n        invalidate_dashboard_caches()\n        \n        app.logger.info(f'Category \"{category_name}\" deleted by user {current_user.id}')\n        return jsonify({'success': True})\n        \n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error deleting category {category_id}: {str(e)}')\n        return jsonify({'error': 'Database error occurred'}), 500\n\n@app.route('/api/event-types', methods=['POST'])\n@login_required\ndef api_add_event_type():\n    from flask import jsonify, request\n    try:\n        type_name = request.form.get('type_name', '').strip()\n        if not type_name:\n            return jsonify({'error': 'Event type name is required'}), 400\n\n        # Check if event type already exists\n        existing_type = EventType.query.filter_by(name=type_name).first()\n        if existing_type:\n            return jsonify({'error': 'Event type already exists'}), 400\n\n        # Create new event type\n        new_event_type = EventType(name=type_name)\n        db.session.add(new_event_type)\n        db.session.commit()\n        \n        # Invalidate caches\n        invalidate_dashboard_caches()\n        \n        app.logger.info(f'Event type \"{type_name}\" added by user {current_user.id}')\n        return jsonify({'success': True, 'id': new_event_type.id, 'name': new_event_type.name})\n        \n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error adding event type: {str(e)}')\n        return jsonify({'error': 'Database error occurred'}), 500\n\n@app.route('/api/event-types/<int:type_id>', methods=['DELETE'])\n@login_required\ndef api_delete_event_type(type_id):\n    from flask import jsonify\n    try:\n        event_type = EventType.query.get_or_404(type_id)\n        \n        # Check if event type is used by any events\n        events_using_type = Event.query.filter_by(event_type_id=type_id).count()\n        if events_using_type > 0:\n            return jsonify({'error': f'Cannot delete event type. It is used by {events_using_type} event(s).'}), 400\n        \n        type_name = event_type.name\n        db.session.delete(event_type)\n        db.session.commit()\n        \n        # Invalidate caches\n        invalidate_dashboard_caches()\n        \n        app.logger.info(f'Event type \"{type_name}\" deleted by user {current_user.id}')\n        return jsonify({'success': True})\n        \n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error deleting event type {type_id}: {str(e)}')\n        return jsonify({'error': 'Database error occurred'}), 500\n\n@app.route('/api/users', methods=['POST'])\n@login_required\ndef api_add_user():\n    from flask import jsonify, request\n    try:\n        email = request.form.get('email', '').strip().lower()\n        password = request.form.get('password', '').strip()\n        role = request.form.get('role', '').strip()\n\n        if not email or not password or not role:\n            return jsonify({'error': 'Email, password, and role are required'}), 400\n\n        # Validate role\n        valid_roles = ['admin', 'event_manager', 'medical_rep']\n        if role not in valid_roles:\n            return jsonify({'error': 'Invalid role specified'}), 400\n\n        # Check if user already exists\n        existing_user = User.query.filter_by(email=email).first()\n        if existing_user:\n            return jsonify({'error': 'User with this email already exists'}), 400\n\n        # Create new user\n        new_user = User()\n        new_user.email = email\n        new_user.role = role\n        new_user.set_password(password)\n\n        db.session.add(new_user)\n        db.session.commit()\n\n        app.logger.info(f'User {email} added successfully with role {role}')\n        return jsonify({\n            'success': True, \n            'id': new_user.id, \n            'email': new_user.email, \n            'role': new_user.role\n        })\n\n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error adding user: {str(e)}')\n        return jsonify({'error': f'Failed to add user: {str(e)}'}), 500\n\n@app.route('/api/users/<int:user_id>', methods=['DELETE'])\n@login_required\ndef api_delete_user(user_id):\n    from flask import jsonify\n    try:\n        # Prevent users from deleting themselves\n        if user_id == current_user.id:\n            return jsonify({'error': 'You cannot delete your own account'}), 400\n\n        user = User.query.get_or_404(user_id)\n        user_email = user.email\n\n        # Check if user has created events\n        event_count = Event.query.filter_by(user_id=user_id).count()\n        if event_count > 0:\n            return jsonify({'error': f'Cannot delete user {user_email} - they have {event_count} associated events'}), 400\n\n        db.session.delete(user)\n        db.session.commit()\n\n        app.logger.info(f'User {user_email} deleted successfully')\n        return jsonify({'success': True})\n\n    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f'Error deleting user: {str(e)}')\n        return jsonify({'error': f'Failed to delete user: {str(e)}'}), 500\n\n@app.route('/api/users/list', methods=['GET'])\n@login_required\ndef api_list_users():\n    from flask import jsonify\n    try:\n        users = User.query.all()\n        users_data = []\n        for user in users:\n            users_data.append({\n                'id': user.id,\n                'email': user.email,\n                'role': user.role\n            })\n\n        return jsonify({'success': True, 'users': users_data})\n\n    except Exception as e:\n        app.logger.error(f'Error listing users: {str(e)}')\n        return jsonify({'error': f'Failed to load users: {str(e)}'}), 500\n\n@app.route('/api/auth/test')\n@login_required\ndef api_auth_test():\n    from flask import jsonify\n    return jsonify({'authenticated': True, 'user': current_user.email, 'role': current_user.role})\n\n# API Token Management Endpoints\n@app.route('/api/tokens', methods=['POST'])\n@login_required\n@limiter.limit(\"5 per hour\")  # Limit token creation\ndef api_create_token():\n    from flask import jsonify, request\n    try:\n        data = request.get_json()\n        token_name = data.get('name', '').strip()\n        \n        if not token_name:\n            return jsonify({'error': 'Token name is required'}), 400\n        \n        # Check if user already has 5 or more active tokens\n        active_tokens = APIToken.query.filter_by(user_id=current_user.id, is_active=True).count()\n        if active_tokens >= 5:\n            return jsonify({'error': 'Maximum of 5 active tokens allowed per user'}), 400\n        \n        token, api_token = APIToken.generate_token(current_user.id, token_name)\n        log_security_event(\"API_TOKEN_CREATED\", f\"Token '{token_name}' created\", user_id=current_user.id)\n        \n        return jsonify({\n            'success': True,\n            'token': token,\n            'token_id': api_token.id,\n            'name': api_token.name,\n            'created_at': api_token.created_at.isoformat()\n        })\n        \n    except Exception as e:\n        app.logger.error(f'Error creating API token: {str(e)}')\n        return jsonify({'error': 'Failed to create token'}), 500\n\n@app.route('/api/tokens', methods=['GET'])\n@login_required\ndef api_list_tokens():\n    from flask import jsonify\n    try:\n        tokens = APIToken.query.filter_by(user_id=current_user.id, is_active=True).all()\n        tokens_data = [{\n            'id': token.id,\n            'name': token.name,\n            'created_at': token.created_at.isoformat(),\n            'last_used': token.last_used.isoformat() if token.last_used else None\n        } for token in tokens]\n        \n        return jsonify({'tokens': tokens_data})\n        \n    except Exception as e:\n        app.logger.error(f'Error listing API tokens: {str(e)}')\n        return jsonify({'error': 'Failed to list tokens'}), 500\n\n@app.route('/api/tokens/<int:token_id>', methods=['DELETE'])\n@login_required\ndef api_delete_token(token_id):\n    from flask import jsonify\n    try:\n        token = APIToken.query.filter_by(id=token_id, user_id=current_user.id).first()\n        if not token:\n            return jsonify({'error': 'Token not found'}), 404\n        \n        token.is_active = False\n        db.session.commit()\n        \n        log_security_event(\"API_TOKEN_REVOKED\", f\"Token '{token.name}' revoked\", user_id=current_user.id)\n        return jsonify({'success': True})\n        \n    except Exception as e:\n        app.logger.error(f'Error deleting API token: {str(e)}')\n        return jsonify({'error': 'Failed to delete token'}), 500\n\n# Protected API endpoints using token authentication\n@app.route('/api/v1/events', methods=['GET'])\n@api_token_required\n@limiter.limit(\"100 per hour\")\ndef api_v1_events():\n    \"\"\"API endpoint for getting events with token authentication\"\"\"\n    from flask import jsonify\n    try:\n        page = request.args.get('page', 1, type=int)\n        per_page = min(request.args.get('per_page', 20, type=int), 100)\n        \n        # Use optimized pagination function\n        events, total_count, has_next, has_prev = get_paginated_events(\n            page=page, \n            per_page=per_page,\n            user_filter=None if current_user.can_approve_events() else current_user.id\n        )\n        \n        events_data = []\n        for event in events:\n            events_data.append({\n                'id': event.id,\n                'name': event.name,\n                'description': event.description,\n                'start_datetime': event.start_datetime.isoformat() if event.start_datetime else None,\n                'end_datetime': event.end_datetime.isoformat() if event.end_datetime else None,\n                'is_online': event.is_online,\n                'status': event.status,\n                'created_at': event.created_at.isoformat() if event.created_at else None\n            })\n        \n        return jsonify({\n            'events': events_data,\n            'pagination': {\n                'page': page,\n                'per_page': per_page,\n                'total': total_count,\n                'has_next': has_next,\n                'has_prev': has_prev\n            }\n        })\n        \n    except Exception as e:\n        app.logger.error(f'Error in API events endpoint: {str(e)}')\n        return jsonify({'error': 'Internal server error'}), 500\n\n@app.route('/forgot_password')\ndef forgot_password():\n    return '<p>Password reset functionality coming soon. Please contact administrator.</p><p><a href=\"/login\">Back to Login</a></p>'\n\n# Initialize database with connection validation\nwith app.app_context():\n    # Test PostgreSQL connection\n    try:\n        db.engine.connect()\n        print(\"✓ PostgreSQL database connection successful\")\n    except Exception as e:\n        print(f\"✗ PostgreSQL database connection failed: {e}\")\n        raise RuntimeError(f\"Failed to connect to PostgreSQL database: {e}\")\n\n    # Create upload directory\n    os.makedirs('static/uploads', exist_ok=True)\n\n    # Create all database tables\n    db.create_all()\n\n    # Create admin user from environment variables if none exists\n    admin_email = os.environ.get('ADMIN_EMAIL')\n    admin_password = os.environ.get('ADMIN_PASSWORD')\n\n    if admin_email and admin_password:\n        if not User.query.filter_by(email=admin_email).first():\n            admin_user = User()\n            admin_user.email = admin_email\n            admin_user.role = 'admin'\n            admin_user.set_password(admin_password)\n            db.session.add(admin_user)\n            db.session.commit()\n            app.logger.info(f'Admin user created from environment: {admin_email}')\n    else:\n        app.logger.warning('ADMIN_EMAIL and ADMIN_PASSWORD environment variables not set - no default admin user created')\n\n    # Create event categories if they don't exist\n    categories = [\n        'Cardiology', 'Oncology', 'Neurology', 'Pediatrics', 'Endocrinology',\n        'Dermatology', 'Psychiatry', 'Product Launch', 'Medical Education',\n        'Patient Awareness', 'Internal Training'\n    ]\n\n    for cat_name in categories:\n        if not EventCategory.query.filter_by(name=cat_name).first():\n            category = EventCategory(name=cat_name)\n            db.session.add(category)\n\n    # Create event types if they don't exist\n    event_types = [\n        'Conference', 'Webinar', 'Workshop', 'Symposium', \n        'Roundtable Meeting', 'Investigator Meeting'\n    ]\n\n    for type_name in event_types:\n        if not EventType.query.filter_by(name=type_name).first():\n            event_type = EventType(name=type_name)\n            db.session.add(event_type)\n\n    db.session.commit()\n\n# Database Backup and Restore API Routes\n@app.route('/api/database/backup', methods=['POST'])\n@login_required\n@limiter.limit(\"5 per hour\")\ndef api_database_backup():\n    \"\"\"Create a database backup and download it\"\"\"\n    from flask import jsonify, make_response\n    import subprocess\n    import tempfile\n    import os\n    from datetime import datetime\n    \n    try:\n        # Only admin users can perform database backup\n        if current_user.role != 'admin':\n            return jsonify({'error': 'Only administrators can create database backups'}), 403\n        \n        # Get database URL from environment\n        database_url = os.environ.get(\"DATABASE_URL\")\n        if not database_url:\n            return jsonify({'error': 'Database URL not configured'}), 500\n        \n        # Create temporary file for backup\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        backup_filename = f\"database_backup_{timestamp}.sql\"\n        \n        with tempfile.NamedTemporaryFile(mode='w+b', delete=False, suffix='.sql') as temp_file:\n            try:\n                # Use pg_dump to create database backup\n                cmd = ['pg_dump', database_url, '--no-owner', '--no-privileges']\n                result = subprocess.run(cmd, capture_output=True, text=True)\n                \n                if result.returncode != 0:\n                    app.logger.error(f'pg_dump failed: {result.stderr}')\n                    return jsonify({'error': 'Failed to create database backup'}), 500\n                \n                # Write backup to temporary file\n                temp_file.write(result.stdout.encode('utf-8'))\n                temp_file.flush()\n                \n                # Read the backup content\n                temp_file.seek(0)\n                backup_content = temp_file.read()\n                \n                # Create response with file download\n                response = make_response(backup_content)\n                response.headers['Content-Type'] = 'application/octet-stream'\n                response.headers['Content-Disposition'] = f'attachment; filename=\"{backup_filename}\"'\n                \n                # Log the backup creation\n                log_security_event(\"DATABASE_BACKUP_CREATED\", f\"Database backup created: {backup_filename}\", user_id=current_user.id)\n                app.logger.info(f'Database backup created successfully by user {current_user.id}')\n                \n                return response\n                \n            finally:\n                # Clean up temporary file\n                try:\n                    os.unlink(temp_file.name)\n                except:\n                    pass\n                    \n    except Exception as e:\n        app.logger.error(f'Error creating database backup: {str(e)}')\n        return jsonify({'error': 'Internal server error occurred during backup'}), 500\n\n@app.route('/api/database/restore', methods=['POST'])\n@login_required\n@limiter.limit(\"2 per hour\")\ndef api_database_restore():\n    \"\"\"Restore database from uploaded backup file\"\"\"\n    from flask import jsonify, request\n    import subprocess\n    import tempfile\n    import os\n    \n    try:\n        # Only admin users can perform database restore\n        if current_user.role != 'admin':\n            return jsonify({'error': 'Only administrators can restore database backups'}), 403\n        \n        # Check if backup file was uploaded\n        if 'backup_file' not in request.files:\n            return jsonify({'error': 'No backup file provided'}), 400\n        \n        backup_file = request.files['backup_file']\n        if backup_file.filename == '':\n            return jsonify({'error': 'No file selected'}), 400\n        \n        # Validate file extension\n        if not backup_file.filename.endswith('.sql'):\n            return jsonify({'error': 'Invalid file type. Only .sql files are allowed'}), 400\n        \n        # Get database URL from environment\n        database_url = os.environ.get(\"DATABASE_URL\")\n        if not database_url:\n            return jsonify({'error': 'Database URL not configured'}), 500\n        \n        # Save uploaded file to temporary location\n        with tempfile.NamedTemporaryFile(mode='w+b', delete=False, suffix='.sql') as temp_file:\n            backup_file.save(temp_file.name)\n            \n            try:\n                # Use psql to restore database\n                cmd = ['psql', database_url, '-f', temp_file.name]\n                result = subprocess.run(cmd, capture_output=True, text=True)\n                \n                if result.returncode != 0:\n                    app.logger.error(f'Database restore failed: {result.stderr}')\n                    return jsonify({'error': 'Failed to restore database backup'}), 500\n                \n                # Log the restore operation\n                log_security_event(\"DATABASE_RESTORE_COMPLETED\", f\"Database restored from {backup_file.filename}\", user_id=current_user.id)\n                app.logger.info(f'Database restored successfully by user {current_user.id} from file {backup_file.filename}')\n                \n                return jsonify({\n                    'success': True, \n                    'message': 'Database restored successfully'\n                })\n                \n            finally:\n                # Clean up temporary file\n                try:\n                    os.unlink(temp_file.name)\n                except:\n                    pass\n                    \n    except Exception as e:\n        app.logger.error(f'Error restoring database: {str(e)}')\n        return jsonify({'error': 'Internal server error occurred during restore'}), 500\n\n    # Log application startup\n    log_security_event(\"APPLICATION_START\", \"Application started successfully\")\n    app.logger.info(\"Database initialization completed with security enhancements\")\n\n","size_bytes":125774},"helpers.py":{"content":"import re\nimport csv\nimport io\nfrom functools import wraps\nfrom flask import flash, redirect, url_for, Response\nfrom flask_login import current_user\n\n# Allowed file extensions for upload\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\n\ndef allowed_file(filename):\n    \"\"\"Check if a filename has an allowed extension\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\ndef admin_required(f):\n    \"\"\"Decorator to require admin role for a route\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not current_user.is_admin():\n            flash('This action requires administrator privileges', 'danger')\n            return redirect(url_for('dashboard'))\n        return f(*args, **kwargs)\n    return decorated_function\n    \ndef not_medical_rep(f):\n    \"\"\"Decorator to restrict medical rep from accessing certain routes\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if current_user.is_medical_rep():\n            flash('Medical representatives do not have access to this feature', 'danger')\n            return redirect(url_for('dashboard'))\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef export_events_to_csv(events):\n    \"\"\"Export events to a CSV file\"\"\"\n    output = io.StringIO()\n    fieldnames = [\n        'id', 'name', 'requester_name', 'is_online', 'start_datetime', \n        'end_datetime', 'registration_deadline', 'governorate', 'venue', \n        'service_request', 'employee_code', 'event_type', 'description', \n        'created_at', 'created_by', 'approval_status', 'categories'\n    ]\n    \n    writer = csv.DictWriter(output, fieldnames=fieldnames)\n    writer.writeheader()\n    \n    for event in events:\n        venue_name = event.venue_details.name if event.venue_details else None\n        service_request_name = event.service_request.name if event.service_request else None\n        employee_code = event.employee.code if event.employee else None\n        event_type = event.event_type.name if event.event_type else None\n        categories = \", \".join([c.name for c in event.categories]) if event.categories else \"\"\n        \n        writer.writerow({\n            'id': event.id,\n            'name': event.name,\n            'requester_name': event.requester_name,\n            'is_online': \"Yes\" if event.is_online else \"No\",\n            'start_datetime': event.start_datetime.strftime('%Y-%m-%d %H:%M'),\n            'end_datetime': event.end_datetime.strftime('%Y-%m-%d %H:%M'),\n            'registration_deadline': event.registration_deadline.strftime('%Y-%m-%d %H:%M'),\n            'governorate': event.governorate,\n            'venue': venue_name,\n            'service_request': service_request_name,\n            'employee_code': employee_code,\n            'event_type': event_type,\n            'description': event.description,\n            'created_at': event.created_at.strftime('%Y-%m-%d %H:%M'),\n            'created_by': event.creator.email,\n            'approval_status': event.status,\n            'categories': categories\n        })\n    \n    return Response(\n        output.getvalue(),\n        mimetype=\"text/csv\",\n        headers={\"Content-disposition\": \"attachment; filename=events_export.csv\"}\n    )\n\ndef get_governorates():\n    \"\"\"Return list of governorates in Egypt\"\"\"\n    return [\n        'Alexandria', 'Aswan', 'Asyut', 'Beheira', 'Beni Suef', \n        'Cairo', 'Dakahlia', 'Damietta', 'Faiyum', 'Gharbia', \n        'Giza', 'Ismailia', 'Kafr El Sheikh', 'Luxor', 'Matruh', \n        'Minya', 'Monufia', 'New Valley', 'North Sinai', 'Port Said', \n        'Qalyubia', 'Qena', 'Red Sea', 'Sharqia', 'Sohag', \n        'South Sinai', 'Suez'\n    ]\n\ndef validate_email(email):\n    \"\"\"Validate email format\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\ndef format_datetime(dt, format='%d %b %Y, %H:%M'):\n    \"\"\"Format datetime object to string\"\"\"\n    if dt:\n        return dt.strftime(format)\n    return ''\n\ndef get_event_badge_class(is_online):\n    \"\"\"Return appropriate badge class based on event type\"\"\"\n    return \"bg-info\" if is_online else \"bg-success\"\n","size_bytes":4159},"main.py":{"content":"from app import app\nimport os\nif __name__ == '__main__':\n    \n    # Get configuration from .env\n    host = os.environ.get('FLASK_HOST', '0.0.0.0')\n    port = int(os.environ.get('FLASK_PORT', '5000'))\n    debug = os.environ.get('FLASK_DEBUG', 'False').lower() == 'true'\n\n    print(f\"Starting Flask server on {host}:{port} (debug={debug})\")\n    app.run(host=host, port=port, debug=debug)","size_bytes":385},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.2.0\",\n    \"flask-login>=0.6.3\",\n    \"flask>=3.1.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"sqlalchemy>=2.0.40\",\n    \"werkzeug>=3.1.3\",\n]\n","size_bytes":355},"replit.md":{"content":"# PharmaEvents - Event Management System\n\n## Overview\nPharmaEvents is a web-based event management application tailored for pharmaceutical companies, focusing on regulatory compliance. It provides a robust platform for creating, managing, and reporting events with role-based access control (Admin, Event Manager, Medical Representative). The system aims to streamline event workflows, enhance data visualization, and ensure secure data handling for the pharmaceutical industry.\n\n## User Preferences\nPreferred communication style: Simple, everyday language.\nConfiguration: Environment variables only - no hardcoded values in source code.\n\n## System Architecture\n\n### Frontend Architecture\n- **Templates**: Jinja2 with Bootstrap 5.3.3 for responsive UI.\n- **CSS**: Bootstrap with custom variables for theming and dark mode.\n- **JavaScript**: Vanilla JS and jQuery.\n- **Libraries**: Font Awesome 6.5.2 (icons), Select2 (enhanced dropdowns), Chart.js 4.4.2 (analytics), Flatpickr (date/time pickers).\n- **Theming**: Light/dark mode toggle via CSS custom properties.\n\n### Backend Architecture\n- **Framework**: Flask 3.1.1 with SQLAlchemy 2.0.40 ORM.\n- **Authentication**: Flask-Login for session management and role-based access control.\n- **Database**: PostgreSQL with strict connection validation.\n- **File Handling**: Werkzeug for secure file uploads (2MB limit, specific image formats).\n- **Deployment**: Gunicorn WSGI server with environment-based configuration.\n\n### Database Schema\n- **Users**: Email-based authentication with roles (admin, event_manager, medical_rep).\n- **Events**: Comprehensive model supporting online/offline, categories, and venue management.\n- **Configuration**: AppSetting for dynamic application settings.\n- **Relationships**: Many-to-many associations for events and categories.\n\n### Key Features\n- **Authentication System**: Role-based access control, password hashing, session management, admin-only routes.\n- **Event Management**: Full CRUD operations with rich metadata, image uploads, multi-category tagging, venue management, and a role-based approval workflow for events.\n- **Dashboard & Analytics**: Real-time statistics with Chart.js, event filtering, export functionality, and role-specific views.\n- **File Management**: Secure handling of image uploads with validation and storage.\n\n### Data Flow\n- **User Authentication**: Login → Session Creation → Role Verification → Dashboard Redirect.\n- **Event Creation**: Form Validation → File Upload Processing → Database Storage → Success Confirmation.\n- **Event Management**: List View → Filter Application → CRUD Operations → Database Updates.\n- **Analytics**: Data Aggregation → Chart Generation → Dashboard Display.\n\n### Deployment Strategy\n- **Development**: PostgreSQL with connection validation, Flask development server.\n- **Production**: PostgreSQL with connection pooling, Gunicorn (4 workers), ProxyFix middleware, environment-based configuration.\n- **Hosting**: Python 3.11, PostgreSQL 16 modules, internal port 4000 mapped to external 80.\n\n### Role-Based Access Control\n- **Admin**: Full system access, can approve/decline all events, view all events and dashboard data.\n- **Event Manager**: Can approve/decline events, view all events and dashboard data, no user management.\n- **Medical Rep**: Can create events (starting in \"pending\" status), only view their own events and dashboard data.\n- **Event Status Flow**: Medical Rep events require approval. Admins/Event Managers can create \"active\" events directly and manage approvals.\n\n## External Dependencies\n\n### Python Packages\n- `flask`, `flask-sqlalchemy`, `flask-login`\n- `psycopg2-binary` (for PostgreSQL)\n- `email-validator`\n- `gunicorn`\n\n### Frontend Libraries\n- Bootstrap 5.3.3\n- Font Awesome 6.5.2\n- Chart.js 4.4.2\n- Select2\n- Flatpickr\n\n## Recent Changes\n\n### August 13, 2025 - Migration Complete and Bug Fixes\n- ✅ **Full Migration Completed**: Successfully migrated PharmaEvents from Replit Agent to standard Replit environment\n- ✅ **Filter & Search Fix**: Fixed event filtering and search functionality on Events page - all filters now work properly\n- ✅ **Category Management Fix**: Fixed adding new categories in Settings - properly saves to database with validation\n- ✅ **Event Type Management Fix**: Fixed adding new event types in Settings - properly saves to database with validation  \n- ✅ **Database Operations**: All API endpoints now properly create, validate, and delete categories/event types\n- ✅ **JavaScript Enhancement**: Added complete client-side handling for all category and event type operations\n- ✅ **Status Filter**: Added missing status filter handling for admin/event manager event filtering\n- ✅ **Cache Integration**: All category/event type operations properly invalidate dashboard caches\n- ✅ **Error Handling**: Added comprehensive error handling and user feedback for all operations\n\n### August 13, 2025 - Replit Agent Migration and Bug Fixes\n- ✅ **Full Migration Completed**: Successfully migrated PharmaEvents from Replit Agent to standard Replit environment\n- ✅ **Filter & Search Fix**: Fixed event filtering and search functionality on Events page - all filters now work properly\n- ✅ **Category Management Fix**: Fixed adding new categories in Settings - properly saves to database with validation\n- ✅ **Event Type Management Fix**: Fixed adding new event types in Settings - properly saves to database with validation  \n- ✅ **Database Operations**: All API endpoints now properly create, validate, and delete categories/event types\n- ✅ **JavaScript Enhancement**: Added complete client-side handling for all category and event type operations\n- ✅ **Status Filter**: Added missing status filter handling for admin/event manager event filtering\n- ✅ **Cache Integration**: All category/event type operations properly invalidate dashboard caches\n- ✅ **Error Handling**: Added comprehensive error handling and user feedback for all operations\n\n### August 13, 2025 - Replit Agent Migration and Bug Fixes\n- ✅ **Migration Completed**: Successfully migrated PharmaEvents from Replit Agent to standard Replit environment\n- ✅ **Dependencies Installed**: Added all required Flask extensions (flask-wtf, flask-limiter, flask-caching, pillow, openpyxl, pandas, numpy, python-dotenv)\n- ✅ **Database Setup**: Created PostgreSQL database and configured environment variables  \n- ✅ **CSV Export Fix**: Fixed context error in events export functionality by converting SQLAlchemy objects to dictionaries within request context\n- ✅ **Environment Configuration**: Set up SESSION_SECRET, ADMIN_EMAIL, and ADMIN_PASSWORD through Replit Secrets\n- ✅ **Application Running**: Successfully deployed on port 5000 with Gunicorn WSGI server\n- ✅ **Form Field Updates**: Made Venue Name, Employee Code, and Service Request ID required fields for event creation\n- ✅ **Registration Deadline Logic**: Automatically calculates registration deadline as 2 days after event end date\n- ✅ **UI Improvements**: Added readonly fields with helpful tooltips for auto-calculated registration deadlines\n- ✅ **Backend Validation**: Updated server-side validation to enforce new required fields\n- ✅ **JavaScript Enhancement**: Added automatic date calculation functionality with real-time updates\n- ✅ **Logo Management**: Added remove logo functionality in application settings with confirmation dialog\n- ✅ **API Enhancement**: Implemented DELETE endpoint for logo removal with file cleanup\n\n### August 12, 2025 - Performance Optimization and Database Improvements\n- ✅ **Database Optimization**: Added comprehensive database indexes for Event model including composite indexes for complex queries\n- ✅ **Caching Layer**: Implemented Flask-Caching with 5-10 minute cache timeouts for dashboard statistics\n- ✅ **Query Optimization**: Replaced inefficient N+1 queries with optimized aggregation using SQLAlchemy functions\n- ✅ **Pagination Implementation**: Enhanced events listing with proper pagination (20 events per page, max 100)\n- ✅ **Memory Optimization**: Implemented streaming CSV export with batch processing (100 events per batch)\n- ✅ **Cache Invalidation**: Added automatic cache clearing when events are created, updated, deleted, or status changed\n- ✅ **Performance Monitoring**: Added logging for cache operations and export progress tracking\n\n### August 12, 2025 - Environment Migration and Bug Fixes\n- ✅ Successfully migrated application from Replit Agent to standard Replit environment\n- ✅ Removed all hardcoded credentials and configuration values from source code\n- ✅ Implemented environment-variable-only configuration with python-dotenv support\n- ✅ Created comprehensive .env.example template for development setup\n- ✅ Added strict PostgreSQL connection validation with error handling\n- ✅ Configured all Flask settings (host, port, debug, session) from environment variables\n- ✅ Set up admin user creation exclusively from ADMIN_EMAIL and ADMIN_PASSWORD environment variables\n- ✅ Application successfully validates required environment variables on startup\n- ✅ Login system working with environment-configured admin credentials (NO hardcoded values)\n- ✅ Dashboard displaying real event data (1 Oncology Conference event)\n- ✅ Removed all unused files and duplicate code for clean environment-only configuration\n- ✅ Fixed application name update functionality - corrected button ID mismatch in settings template\n\n### Performance Optimization Benefits Achieved\n- **Reduced Database Load**: Dashboard queries now use single aggregated queries instead of multiple separate queries\n- **Faster Response Times**: Critical dashboard statistics cached for 5-10 minutes reducing database hits\n- **Scalable Export**: Large event exports no longer cause memory issues with streaming implementation\n- **Efficient Pagination**: Events listing supports up to 100 events per page with proper indexing\n- **Smart Caching**: Automatic cache invalidation ensures data consistency while maintaining performance\n- **Database Indexes**: 15+ strategic indexes covering all frequent query patterns including composite indexes for complex filters\n\n### Migration Benefits Achieved\n- Zero hardcoded sensitive information in codebase\n- Proper separation of configuration from code\n- Enhanced security with Replit Secrets integration\n- Easy deployment across different environments\n- Development-friendly with .env.example guidance","size_bytes":10481},"static/css/styles.css":{"content":"/* Main Styles for PharmaEvents */\n\n:root {\n  --primary: #0f6e84;\n  --primary-dark: #0a5a6d;\n  --secondary: #4caf50;\n  --secondary-dark: #388e3c;\n  --light: #f8f9fa;\n  --gray: #6c757d;\n  --dark: #343a40;\n  --danger: #dc3545;\n  --warning: #ffc107;\n  --success: #28a745;\n  --info: #17a2b8;\n}\n\n/* Theme Color Classes */\n[data-theme-color=\"blue\"] {\n    --primary: #0f6e84;\n    --primary-dark: #0a5a6e;\n}\n\n[data-theme-color=\"green\"] {\n    --primary: #198754;\n    --primary-dark: #146c43;\n}\n\n[data-theme-color=\"purple\"] {\n    --primary: #6f42c1;\n    --primary-dark: #59359a;\n}\n\n[data-theme-color=\"red\"] {\n    --primary: #dc3545;\n    --primary-dark: #b02a37;\n}\n\n[data-theme-color=\"orange\"] {\n    --primary: #fd7e14;\n    --primary-dark: #e8690b;\n}\n\nbody {\n  font-family: 'Roboto', sans-serif;\n  background-color: #f5f7f9;\n  color: #333;\n}\n\n/* Navbar */\n.navbar {\n  background-color: var(--primary);\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.navbar-brand {\n  font-weight: 700;\n  color: white !important;\n}\n\n.navbar-nav .nav-link {\n  color: rgba(255, 255, 255, 0.85) !important;\n  font-weight: 500;\n}\n\n.navbar-nav .nav-link:hover {\n  color: white !important;\n}\n\n.navbar-nav .active .nav-link {\n  color: white !important;\n  font-weight: 700;\n}\n\n/* Cards */\n.card {\n  border: none;\n  border-radius: 0.5rem;\n  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);\n  margin-bottom: 1.5rem;\n  transition: transform 0.3s, box-shadow 0.3s;\n}\n\n.card:hover {\n  transform: translateY(-3px);\n  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n  background-color: rgba(0, 0, 0, 0.03);\n  border-bottom: 1px solid rgba(0, 0, 0, 0.125);\n  font-weight: 600;\n}\n\n/* Buttons */\n.btn-primary {\n  background-color: var(--primary);\n  border-color: var(--primary);\n}\n\n.btn-primary:hover {\n  background-color: var(--primary-dark);\n  border-color: var(--primary-dark);\n}\n\n.btn-secondary {\n  background-color: var(--secondary);\n  border-color: var(--secondary);\n}\n\n.btn-secondary:hover {\n  background-color: var(--secondary-dark);\n  border-color: var(--secondary-dark);\n}\n\n/* Login Page */\n.login-container {\n  min-height: 100vh;\n  display: flex;\n  align-items: center;\n  padding: 40px 0;\n}\n\n.login-left {\n  padding: 2rem;\n}\n\n.login-right {\n  background-color: white;\n  padding: 2rem;\n  border-radius: 0.5rem;\n  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);\n}\n\n.login-logo {\n  margin-bottom: 1.5rem;\n  color: var(--primary);\n}\n\n.login-title {\n  font-weight: 700;\n  margin-bottom: 1.5rem;\n  color: var(--primary);\n}\n\n/* Dashboard */\n.stat-card {\n  text-align: center;\n  padding: 1.5rem;\n}\n\n.stat-card .stat-value {\n  font-size: 2.5rem;\n  font-weight: 700;\n  margin-bottom: 0.5rem;\n}\n\n.stat-card .stat-label {\n  font-size: 0.875rem;\n  color: var(--gray);\n  text-transform: uppercase;\n  letter-spacing: 1px;\n}\n\n.chart-container {\n  position: relative;\n  height: 350px;\n  margin-bottom: 1.5rem;\n}\n\n/* Event Cards */\n.event-card {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n\n.event-card .card-img-top {\n  height: 180px;\n  object-fit: cover;\n}\n\n.event-banner {\n  position: relative;\n}\n\n.event-badge {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  padding: 0.25rem 0.5rem;\n  border-radius: 0.25rem;\n  font-size: 0.75rem;\n  font-weight: 600;\n  text-transform: uppercase;\n}\n\n.event-details {\n  flex-grow: 1;\n}\n\n.event-category {\n  display: inline-block;\n  margin-right: 0.5rem;\n  margin-bottom: 0.5rem;\n  padding: 0.25rem 0.5rem;\n  background-color: rgba(15, 110, 132, 0.1);\n  color: var(--primary);\n  border-radius: 0.25rem;\n  font-size: 0.75rem;\n}\n\n.event-info-icon {\n  color: var(--gray);\n  width: 1rem;\n  margin-right: 0.5rem;\n}\n\n.event-actions {\n  margin-top: auto;\n}\n\n/* Forms */\n.form-label {\n  font-weight: 500;\n}\n\n.required-field::after {\n  content: \"*\";\n  color: var(--danger);\n  margin-left: 4px;\n}\n\n.custom-file-label {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n/* Settings Page */\n.settings-section {\n  margin-bottom: 2rem;\n}\n\n.settings-header {\n  margin-bottom: 1rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n}\n\n/* User Menu */\n.user-avatar {\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n  background: linear-gradient(45deg, #6a11cb, #2575fc);\n  color: white;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: 600;\n}\n\n.user-menu {\n  min-width: 200px;\n  max-width: 280px;\n  right: 0 !important;\n  left: auto !important;\n  transform: none !important;\n  margin-top: 0.5rem;\n  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);\n  border: none;\n  max-height: 80vh;\n  overflow-y: auto;\n}\n\n/* Ensure dropdown stays within viewport */\n.dropdown-menu-end {\n  --bs-position: end;\n  right: 0 !important;\n  left: auto !important;\n  transform: translateX(0) !important;\n}\n\n/* Parent dropdown container positioning */\n.dropdown {\n  position: relative;\n}\n\n.dropdown-menu {\n  position: absolute;\n  z-index: 1050;\n  display: none;\n  min-width: 10rem;\n  padding: 0.5rem 0;\n  margin: 0;\n  font-size: 1rem;\n  color: #212529;\n  text-align: left;\n  list-style: none;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  border-radius: 0.375rem;\n}\n\n/* Fix positioning for responsive screens */\n@media (max-width: 768px) {\n  .user-menu {\n    min-width: 180px;\n    max-width: 95vw;\n    right: 0.5rem !important;\n    left: auto !important;\n    margin-right: 0;\n    position: fixed !important;\n    top: 60px !important;\n  }\n  \n  .navbar .dropdown-menu.show {\n    right: 0.5rem !important;\n    left: auto !important;\n  }\n}\n\n/* Prevent dropdown from going off screen on small screens */\n@media (max-width: 480px) {\n  .user-menu {\n    min-width: 160px;\n    max-width: 90vw;\n    right: 0.25rem !important;\n  }\n}\n\n.dropdown-role {\n  padding: 0.25rem 1.5rem;\n  font-size: 0.875rem;\n  color: var(--gray);\n}\n\n.dropdown-role-item {\n  padding-left: 2rem;\n}\n\n.dropdown-role-item.active {\n  background-color: var(--primary);\n  color: white;\n}\n\n/* Charts */\n.chart-section {\n  margin-bottom: 2rem;\n}\n\n.chart-section .card-header {\n  background-color: var(--primary);\n  color: white;\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n  .login-left {\n    display: none;\n  }\n\n  .stat-card .stat-value {\n    font-size: 2rem;\n  }\n\n  .chart-container {\n    height: 300px;\n  }\n}\n\n/* Utility Classes */\n.text-primary {\n  color: var(--primary) !important;\n}\n\n.bg-primary {\n  background-color: var(--primary) !important;\n}\n\n.bg-secondary {\n  background-color: var(--secondary) !important;\n}\n\n.text-overflow-ellipsis {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n/* Loading spinner */\n.loading-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(255, 255, 255, 0.7);\n  display: none; /* Hidden by default */\n  align-items: center;\n  justify-content: center;\n  z-index: 9999;\n  transition: all 0.3s ease;\n}\n\n[data-bs-theme=\"dark\"] .loading-overlay {\n  background-color: rgba(33, 37, 41, 0.8);\n}\n\n.spinner-border {\n  width: 3rem;\n  height: 3rem;\n}\n\n/* Style for loading message */\n.loading-message {\n  margin-top: 1rem;\n  color: var(--primary);\n  font-weight: 500;\n}\n\n/* Color Picker Styles */\n.form-control-color {\n    width: 80px;\n    height: 50px;\n    border-radius: 8px;\n    border: 2px solid #ddd;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.form-control-color:hover {\n    border-color: var(--primary);\n    transform: scale(1.05);\n}\n\n.color-preview {\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.preset-color {\n    min-width: 80px;\n    margin-bottom: 0.5rem;\n    border: 2px solid transparent !important;\n    transition: all 0.3s ease;\n}\n\n.preset-color:hover {\n    border-color: #fff !important;\n    box-shadow: 0 0 0 2px var(--primary);\n    transform: translateY(-2px);\n}\n\n.current-theme-display {\n    transition: all 0.3s ease;\n    font-family: 'Courier New', monospace;\n}\n\n/* Color Wheel Styles */","size_bytes":7943},"static/js/create_event.js":{"content":"// Create Event JavaScript for PharmaEvents\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    // We'll use native date/time inputs instead of flatpickr to avoid validation issues\n\n    // Initialize select2 for multi-select\n    if (typeof $.fn.select2 !== 'undefined') {\n        $('.select2').select2({\n            theme: 'bootstrap4',\n            width: '100%'\n        });\n    }\n\n    // File upload preview functionality\n    const attendeesFileInput = document.getElementById('attendees_file');\n    const filePreview = document.getElementById('file_preview');\n    const fileName = document.getElementById('file_name');\n\n    if (attendeesFileInput) {\n        attendeesFileInput.addEventListener('change', function() {\n            if (this.files && this.files[0]) {\n                const file = this.files[0];\n                fileName.textContent = file.name;\n                filePreview.classList.remove('d-none');\n                \n                // Validate file type\n                const allowedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];\n                const allowedExtensions = ['.xlsx', '.xls', '.csv'];\n                const fileExtension = '.' + file.name.split('.').pop().toLowerCase();\n                \n                if (!allowedExtensions.includes(fileExtension)) {\n                    filePreview.className = 'alert alert-danger';\n                    fileName.textContent = file.name + ' - Invalid file type! Please upload .xlsx, .xls, or .csv files only.';\n                } else {\n                    filePreview.className = 'alert alert-info';\n                }\n            } else {\n                filePreview.classList.add('d-none');\n            }\n        });\n    }\n\n    // Venue is now free text, no dropdown handling needed\n\n    // Online event toggle logic\n    const onlineCheckbox = document.getElementById('is_online');\n    const venueFields = document.getElementById('venue_fields');\n\n    if (onlineCheckbox && venueFields) {\n        onlineCheckbox.addEventListener('change', function() {\n            if (this.checked) {\n                venueFields.classList.add('d-none');\n            } else {\n                venueFields.classList.remove('d-none');\n            }\n        });\n\n        // Initial state\n        if (onlineCheckbox.checked) {\n            venueFields.classList.add('d-none');\n        }\n    }\n\n    // Auto-calculate registration deadline (2 days after end date)\n    const endDateInput = document.getElementById('end_date');\n    const endTimeInput = document.getElementById('end_time');\n    const regDeadlineDateInput = document.getElementById('registration_deadline_date');\n    const regDeadlineTimeInput = document.getElementById('registration_deadline_time');\n\n    function calculateRegistrationDeadline() {\n        if (endDateInput.value) {\n            const endDate = new Date(endDateInput.value);\n            // Add 2 days\n            endDate.setDate(endDate.getDate() + 2);\n            \n            // Format date as YYYY-MM-DD\n            const year = endDate.getFullYear();\n            const month = String(endDate.getMonth() + 1).padStart(2, '0');\n            const day = String(endDate.getDate()).padStart(2, '0');\n            const formattedDate = `${year}-${month}-${day}`;\n            \n            regDeadlineDateInput.value = formattedDate;\n            \n            // If end time is set, use the same time for registration deadline\n            if (endTimeInput.value) {\n                regDeadlineTimeInput.value = endTimeInput.value;\n            }\n        }\n    }\n\n    // Listen for changes to end date and time\n    if (endDateInput && regDeadlineDateInput) {\n        endDateInput.addEventListener('change', calculateRegistrationDeadline);\n        endTimeInput.addEventListener('change', function() {\n            if (regDeadlineDateInput.value && endTimeInput.value) {\n                regDeadlineTimeInput.value = endTimeInput.value;\n            }\n        });\n    }\n\n    // Form validation and submission\n    const form = document.getElementById('event_form');\n    const submitButton = document.getElementById('submit_event_btn');\n\n    if (form && submitButton) {\n        // Listen for form submission\n        form.addEventListener('submit', function(event) {\n            event.preventDefault();\n            \n            // Basic validation\n            const title = document.getElementById('title').value.trim();\n            const description = document.getElementById('description').value.trim();\n            const startDate = document.getElementById('start_date').value;\n            const startTime = document.getElementById('start_time').value;\n            const endDate = document.getElementById('end_date').value;\n            const endTime = document.getElementById('end_time').value;\n            \n            // Check required fields\n            if (!title) {\n                alert('Event title is required');\n                return false;\n            }\n\n            if (!startDate || !startTime) {\n                alert('Start date and time are required');\n                return false;\n            }\n\n            if (!endDate || !endTime) {\n                alert('End date and time are required');\n                return false;\n            }\n\n            if (!description) {\n                alert('Event description is required');\n                return false;\n            }\n\n            // Validate dates - convert to ISO format to ensure proper parsing\n            try {\n                const startDateTime = new Date(`${startDate}T${startTime}:00`);\n                const endDateTime = new Date(`${endDate}T${endTime}:00`);\n                const now = new Date();\n\n                // Check if dates are valid\n                if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {\n                    alert('Invalid date or time format. Please use the date/time selectors.');\n                    return false;\n                }\n\n                // Validation checks\n                if (startDateTime < now) {\n                    alert('Start date cannot be in the past');\n                    return false;\n                }\n\n                if (endDateTime < startDateTime) {\n                    alert('End date must be after or equal to start date');\n                    return false;\n                }\n            } catch (e) {\n                console.error('Date validation error:', e);\n                alert('There was a problem with the date format. Please ensure all dates are correctly formatted.');\n                return false;\n            }\n\n            // Show loading overlay\n            const loadingOverlay = document.getElementById('loading_overlay');\n            if (loadingOverlay) {\n                loadingOverlay.style.display = 'flex';\n            }\n\n            // Disable submit button to prevent double submission\n            submitButton.disabled = true;\n            submitButton.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\" role=\"status\" aria-hidden=\"true\"></span> Processing...';\n\n            // Submit the form\n            form.submit();\n        });\n    }\n});\n\n// Update venue options based on selected governorate\nfunction updateVenueOptions(governorate) {\n    const venueSelect = document.getElementById('venue_id');\n    if (!venueSelect) return;\n\n    // Disable select during update\n    venueSelect.disabled = true;\n\n    // Get all venue options\n    const venueOptions = venueSelect.querySelectorAll('option');\n\n    // Show only venues in the selected governorate\n    venueOptions.forEach(option => {\n        const venueGovernorate = option.getAttribute('data-governorate');\n\n        if (!venueGovernorate || option.value === '') {\n            // Always show the default \"Select a venue\" option\n            option.style.display = '';\n        } else if (venueGovernorate === governorate) {\n            option.style.display = '';\n        } else {\n            option.style.display = 'none';\n        }\n    });\n\n    // Reset selection if current selection is now hidden\n    const selectedOption = venueSelect.options[venueSelect.selectedIndex];\n    if (selectedOption && selectedOption.style.display === 'none') {\n        venueSelect.value = '';\n    }\n\n    // Re-enable select\n    venueSelect.disabled = false;\n}\n\n// Validate the event form\nfunction validateEventForm() {\n    let isValid = true;\n    const form = document.getElementById('event_form');\n\n    // Reset previous error messages\n    const errorMessages = form.querySelectorAll('.error-message');\n    errorMessages.forEach(msg => msg.remove());\n\n    // Check required fields\n    const requiredFields = form.querySelectorAll('[required]');\n    requiredFields.forEach(field => {\n        field.classList.remove('is-invalid');\n\n        if (!field.value.trim()) {\n            field.classList.add('is-invalid');\n            addErrorMessage(field, 'This field is required');\n            isValid = false;\n        }\n    });\n\n    // Get date and time values\n    const startDateVal = document.getElementById('start_date').value;\n    const startTimeVal = document.getElementById('start_time').value;\n    const endDateVal = document.getElementById('end_date').value;\n    const endTimeVal = document.getElementById('end_time').value;\n    \n    // Format for proper parsing\n    let startDateObj, endDateObj;\n    const now = new Date();\n    \n    try {\n        // Parse date strings properly using local date objects\n        // Format: yyyy-mm-dd hh:mm\n        startDateObj = new Date(`${startDateVal} ${startTimeVal}`);\n        endDateObj = new Date(`${endDateVal} ${endTimeVal}`);\n        \n        // Debug info to console\n        console.log('Start Date:', startDateVal, startTimeVal, startDateObj);\n        console.log('End Date:', endDateVal, endTimeVal, endDateObj);\n    } catch (e) {\n        console.error('Date parsing error:', e);\n    }\n\n    // Validate start date\n    if (!startDateVal || !startTimeVal || isNaN(startDateObj.getTime())) {\n        document.getElementById('start_date').classList.add('is-invalid');\n        document.getElementById('start_time').classList.add('is-invalid');\n        addErrorMessage(document.getElementById('start_date'), 'Please enter valid start date and time');\n        isValid = false;\n    }\n\n    // Validate end date\n    if (!endDateVal || !endTimeVal || isNaN(endDateObj.getTime())) {\n        document.getElementById('end_date').classList.add('is-invalid');\n        document.getElementById('end_time').classList.add('is-invalid');\n        addErrorMessage(document.getElementById('end_date'), 'Please enter valid end date and time');\n        isValid = false;\n    }\n\n    // Check date logic only if all dates are valid\n    if (isValid) {\n        // End date should be equal to or after start date\n        if (endDateObj < startDateObj) {\n            document.getElementById('end_date').classList.add('is-invalid');\n            addErrorMessage(document.getElementById('end_date'), 'End date must be after or equal to start date');\n            isValid = false;\n        }\n    }\n\n    // Check if a category is selected\n    const categories = document.getElementById('categories');\n    if (categories && !categories.value) {\n        categories.classList.add('is-invalid');\n        addErrorMessage(categories, 'Please select a category');\n        isValid = false;\n    }\n\n    // Check venue selection for offline events\n    const isOnline = document.getElementById('is_online').checked;\n    if (!isOnline) {\n        const governorate = document.getElementById('governorate');\n        if (!governorate.value) {\n            addErrorMessage(governorate, 'Please select a governorate for offline events');\n            isValid = false;\n        }\n    }\n\n    return isValid;\n}\n\n// Add error message below a field\nfunction addErrorMessage(field, message) {\n    const errorDiv = document.createElement('div');\n    errorDiv.className = 'invalid-feedback error-message';\n    errorDiv.textContent = message;\n\n    field.parentNode.appendChild(errorDiv);\n}\n\n// Add additional initialization code when the document is ready\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Set min dates to today for all date inputs\n    const today = new Date();\n    const todayStr = today.toISOString().split('T')[0];\n    \n    const dateInputs = document.querySelectorAll('input[type=\"date\"]');\n    dateInputs.forEach(input => {\n        input.min = todayStr;\n    });\n    \n    // Image preview handler for event banner\n    const imageInput = document.getElementById('event_banner');\n    const imagePreview = document.getElementById('image_preview');\n    const imagePreviewContainer = document.getElementById('image_preview_container');\n    \n    if (imageInput && imagePreview && imagePreviewContainer) {\n        imageInput.addEventListener('change', function() {\n            const file = this.files[0];\n            if (file) {\n                const reader = new FileReader();\n                reader.onload = function(e) {\n                    imagePreview.src = e.target.result;\n                    imagePreviewContainer.classList.remove('d-none');\n                };\n                reader.readAsDataURL(file);\n            }\n        });\n    }\n});","size_bytes":13225},"static/js/dashboard.js":{"content":"// Dashboard JavaScript for PharmaEvents\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Wait for Chart.js to be fully loaded\n    function initDashboard() {\n        if (typeof Chart === 'undefined') {\n            setTimeout(initDashboard, 100);\n            return;\n        }\n        \n        // Initialize Category Chart\n        const categoryChartCtx = document.getElementById('categoryChart');\n        if (categoryChartCtx) {\n            initCategoryChart();\n        }\n        \n        // Initialize Event Type Distribution Chart\n        const typeChartCtx = document.getElementById('typeChart');\n        if (typeChartCtx) {\n            initTypeChart();\n        }\n        \n        // Initialize Monthly Events Chart\n        const monthlyChartCtx = document.getElementById('monthlyChart');\n        if (monthlyChartCtx) {\n            initMonthlyChart();\n        }\n        \n        // Initialize Requester Chart\n        const requesterChartCtx = document.getElementById('requesterChart');\n        if (requesterChartCtx) {\n            initRequesterChart();\n        }\n        \n        // Load dashboard statistics\n        loadDashboardStats();\n        \n        // Initialize dashboard filters\n        initDashboardFilters();\n    }\n    \n    initDashboard();\n});\n\n// Load dashboard statistics\nfunction loadDashboardStats() {\n    fetch('/api/dashboard/stats', { \n        credentials: 'include',\n        headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n        }\n    })\n        .then(response => {\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            return response.json();\n        })\n        .then(data => {\n            // Update stat cards safely\n            const upcomingElement = document.getElementById('upcoming_events_count');\n            const onlineElement = document.getElementById('online_events_count');\n            const offlineElement = document.getElementById('offline_events_count');\n            const totalElement = document.getElementById('total_events_count');\n            \n            if (upcomingElement) upcomingElement.textContent = data.upcoming_events || 0;\n            if (onlineElement) onlineElement.textContent = data.online_events || 0;\n            if (offlineElement) offlineElement.textContent = data.offline_events || 0;\n            if (totalElement) totalElement.textContent = data.total_events || 0;\n        })\n        .catch(error => {\n            console.error('Error loading dashboard statistics:', error);\n            // Set default values on error\n            const elements = ['upcoming_events_count', 'online_events_count', 'offline_events_count', 'total_events_count'];\n            elements.forEach(id => {\n                const element = document.getElementById(id);\n                if (element) element.textContent = '0';\n            });\n        });\n}\n\n// Initialize Category Chart\nfunction initCategoryChart() {\n    fetch('/api/dashboard/categories', { \n        credentials: 'include',\n        headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n        }\n    })\n    .then(response => response.json())\n    .then(data => {\n        const labels = data.map(item => item.name);\n        const counts = data.map(item => item.count);\n        \n        // Generate colors\n        const backgroundColors = generateColors(data.length);\n        \n        const categoryChart = new Chart(document.getElementById('categoryChart'), {\n            type: 'doughnut',\n            data: {\n                labels: labels,\n                datasets: [{\n                    data: counts,\n                    backgroundColor: backgroundColors,\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        position: 'bottom',\n                        labels: {\n                            padding: 20,\n                            usePointStyle: true,\n                            pointStyle: 'circle'\n                        }\n                    },\n                    title: {\n                        display: true,\n                        text: 'Events by Category',\n                        font: {\n                            size: 16\n                        }\n                    }\n                }\n            }\n        });\n    })\n    .catch(error => {\n        console.error('Error loading category data:', error);\n        // Show empty chart on error\n        const categoryChart = new Chart(document.getElementById('categoryChart'), {\n            type: 'doughnut',\n            data: {\n                labels: ['No Data'],\n                datasets: [{\n                    data: [1],\n                    backgroundColor: ['#e9ecef'],\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        position: 'bottom'\n                    },\n                    title: {\n                        display: true,\n                        text: 'Events by Category',\n                        font: {\n                            size: 16\n                        }\n                    }\n                }\n            }\n        });\n    });\n}\n\n// Initialize Event Type Distribution Chart\nfunction initTypeChart() {\n    fetch('/api/dashboard/event-types', { \n        credentials: 'include',\n        headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n        }\n    })\n    .then(response => response.json())\n    .then(data => {\n        const labels = data.map(item => item.name);\n        const counts = data.map(item => item.count);\n        \n        const typeChart = new Chart(document.getElementById('typeChart'), {\n            type: 'bar',\n            data: {\n                labels: labels,\n                datasets: [{\n                    label: 'Events by Type',\n                    data: counts,\n                    backgroundColor: [\n                        'rgba(255, 99, 132, 0.8)',\n                        'rgba(54, 162, 235, 0.8)',\n                        'rgba(255, 206, 86, 0.8)',\n                        'rgba(75, 192, 192, 0.8)',\n                        'rgba(153, 102, 255, 0.8)',\n                        'rgba(255, 159, 64, 0.8)'\n                    ],\n                    borderColor: [\n                        'rgb(255, 99, 132)',\n                        'rgb(54, 162, 235)',\n                        'rgb(255, 206, 86)',\n                        'rgb(75, 192, 192)',\n                        'rgb(153, 102, 255)',\n                        'rgb(255, 159, 64)'\n                    ],\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                indexAxis: 'y',\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    title: {\n                        display: true,\n                        text: 'Event Types Distribution',\n                        font: {\n                            size: 16\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Number of Events'\n                        }\n                    }\n                }\n            }\n        });\n    })\n    .catch(error => {\n        console.error('Error loading event type data:', error);\n        // Show empty chart on error\n        const typeChart = new Chart(document.getElementById('typeChart'), {\n            type: 'bar',\n            data: {\n                labels: ['No Data'],\n                datasets: [{\n                    label: 'Events by Type',\n                    data: [1],\n                    backgroundColor: ['#e9ecef'],\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                indexAxis: 'y',\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    title: {\n                        display: true,\n                        text: 'Event Types Distribution',\n                        font: {\n                            size: 16\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Number of Events'\n                        }\n                    }\n                }\n            }\n        });\n    });\n}\n\n// Initialize Monthly Events Chart\nfunction initMonthlyChart() {\n    fetch('/api/dashboard/monthly', { \n        credentials: 'include',\n        headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n        }\n    })\n    .then(response => response.json())\n    .then(data => {\n        const monthlyChart = new Chart(document.getElementById('monthlyChart'), {\n            type: 'bar',\n            data: {\n                labels: data.labels || ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n                datasets: [{\n                    label: 'Events per Month',\n                    data: data.data || [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                    backgroundColor: 'rgba(15, 110, 132, 0.8)',\n                    borderColor: 'rgb(15, 110, 132)',\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    title: {\n                        display: true,\n                        text: 'Monthly Event Volume (Last 12 Months)',\n                        font: {\n                            size: 16\n                        }\n                    }\n                },\n                scales: {\n                    y: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Number of Events'\n                        },\n                        ticks: {\n                            stepSize: 1\n                        }\n                    }\n                }\n            }\n        });\n    })\n    .catch(error => {\n        console.error('Error loading monthly data:', error);\n        // Show empty chart on error\n        const monthlyChart = new Chart(document.getElementById('monthlyChart'), {\n            type: 'bar',\n            data: {\n                labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n                datasets: [{\n                    label: 'Events per Month',\n                    data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                    backgroundColor: 'rgba(15, 110, 132, 0.8)',\n                    borderColor: 'rgb(15, 110, 132)',\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    title: {\n                        display: true,\n                        text: 'Monthly Event Volume (Last 12 Months)',\n                        font: {\n                            size: 16\n                        }\n                    }\n                },\n                scales: {\n                    y: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Number of Events'\n                        },\n                        ticks: {\n                            stepSize: 1\n                        }\n                    }\n                }\n            }\n        });\n    });\n}\n\n// Initialize Requester Chart\nfunction initRequesterChart() {\n    fetch('/api/dashboard/requesters', { \n        credentials: 'include',\n        headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n        }\n    })\n    .then(response => response.json())\n    .then(data => {\n        const labels = data.map(item => item.name);\n        const counts = data.map(item => item.count);\n        \n        const requesterChart = new Chart(document.getElementById('requesterChart'), {\n            type: 'bar',\n            data: {\n                labels: labels,\n                datasets: [{\n                    axis: 'y',\n                    label: 'Events Created',\n                    data: counts,\n                    backgroundColor: [\n                        'rgba(54, 162, 235, 0.8)',\n                        'rgba(255, 206, 86, 0.8)',\n                        'rgba(255, 99, 132, 0.8)',\n                        'rgba(75, 192, 192, 0.8)',\n                        'rgba(153, 102, 255, 0.8)'\n                    ],\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                indexAxis: 'y',\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    title: {\n                        display: true,\n                        text: 'Events by Requester',\n                        font: {\n                            size: 16\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Number of Events'\n                        }\n                    }\n                }\n            }\n        });\n    })\n    .catch(error => {\n        console.error('Error loading requester data:', error);\n        // Show empty chart on error\n        const requesterChart = new Chart(document.getElementById('requesterChart'), {\n            type: 'bar',\n            data: {\n                labels: ['No Data'],\n                datasets: [{\n                    axis: 'y',\n                    label: 'Events Created',\n                    data: [1],\n                    backgroundColor: ['#e9ecef'],\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                indexAxis: 'y',\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    title: {\n                        display: true,\n                        text: 'Events by Requester',\n                        font: {\n                            size: 16\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Number of Events'\n                        }\n                    }\n                }\n            }\n        });\n    });\n}\n\n// Helper function to generate random colors for charts\nfunction generateColors(count) {\n    const colors = [\n        'rgba(255, 99, 132, 0.8)',\n        'rgba(54, 162, 235, 0.8)',\n        'rgba(255, 206, 86, 0.8)',\n        'rgba(75, 192, 192, 0.8)',\n        'rgba(153, 102, 255, 0.8)',\n        'rgba(255, 159, 64, 0.8)',\n        'rgba(199, 199, 199, 0.8)',\n        'rgba(83, 102, 255, 0.8)',\n        'rgba(78, 205, 196, 0.8)',\n        'rgba(255, 99, 255, 0.8)',\n        'rgba(107, 91, 149, 0.8)',\n        'rgba(66, 133, 244, 0.8)'\n    ];\n    \n    // If we need more colors than provided, generate them\n    if (count > colors.length) {\n        for (let i = colors.length; i < count; i++) {\n            const r = Math.floor(Math.random() * 255);\n            const g = Math.floor(Math.random() * 255);\n            const b = Math.floor(Math.random() * 255);\n            colors.push(`rgba(${r}, ${g}, ${b}, 0.8)`);\n        }\n    }\n    \n    return colors.slice(0, count);\n}\n\n// Dashboard Filter Functionality\nfunction initDashboardFilters() {\n    // Initialize search input\n    const searchInput = document.getElementById('dashboard_search');\n    if (searchInput) {\n        searchInput.addEventListener('keydown', function(e) {\n            if (e.key === 'Enter') {\n                applyDashboardFilters();\n            }\n        });\n        \n        // Add real-time search with debounce\n        let searchTimeout;\n        searchInput.addEventListener('input', function() {\n            clearTimeout(searchTimeout);\n            searchTimeout = setTimeout(applyDashboardFilters, 500);\n        });\n    }\n    \n    // Initialize filter change events\n    const filterControls = document.querySelectorAll('.dashboard-filter');\n    filterControls.forEach(control => {\n        control.addEventListener('change', function() {\n            applyDashboardFilters();\n        });\n    });\n}\n\n// Apply dashboard filters and refresh data\nfunction applyDashboardFilters() {\n    const searchInput = document.getElementById('dashboard_search');\n    const categorySelect = document.getElementById('category_filter');\n    const typeSelect = document.getElementById('type_filter');\n    const dateSelect = document.getElementById('date_filter');\n    \n    // Build query string\n    const params = new URLSearchParams();\n    \n    if (searchInput && searchInput.value.trim()) {\n        params.append('search', searchInput.value.trim());\n    }\n    \n    if (categorySelect && categorySelect.value !== 'all') {\n        params.append('category', categorySelect.value);\n    }\n    \n    if (typeSelect && typeSelect.value !== 'all') {\n        params.append('type', typeSelect.value);\n    }\n    \n    if (dateSelect && dateSelect.value !== 'all') {\n        params.append('date', dateSelect.value);\n    }\n    \n    // Redirect with filters to reload the dashboard\n    window.location.href = `/dashboard?${params.toString()}`;\n}\n\n// Function to clear all dashboard filters\nfunction clearDashboardFilters() {\n    // Reset all filter controls\n    const searchInput = document.getElementById('dashboard_search');\n    if (searchInput) searchInput.value = '';\n    \n    const filterSelects = document.querySelectorAll('.dashboard-filter');\n    filterSelects.forEach(select => {\n        select.value = 'all';\n    });\n    \n    // Redirect to dashboard page without params\n    window.location.href = '/dashboard';\n}\n","size_bytes":19103},"static/js/events.js":{"content":"// Events JavaScript for PharmaEvents\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Initialize search functionality\n    const searchForm = document.getElementById('search_form');\n    if (searchForm) {\n        searchForm.addEventListener('submit', function(e) {\n            e.preventDefault();\n            applyFilters();\n        });\n    }\n    \n    // Initialize filter change events\n    const filterControls = document.querySelectorAll('.filter-control');\n    filterControls.forEach(control => {\n        control.addEventListener('change', function() {\n            applyFilters();\n        });\n    });\n    \n    // Initialize event deletion\n    const deleteButtons = document.querySelectorAll('.btn-delete-event');\n    deleteButtons.forEach(button => {\n        button.addEventListener('click', function(e) {\n            e.preventDefault();\n            const eventId = this.getAttribute('data-event-id');\n            const eventName = this.getAttribute('data-event-name');\n            \n            confirmAction(`Are you sure you want to delete event \"${eventName}\"? This action cannot be undone.`, function() {\n                const form = document.createElement('form');\n                form.method = 'POST';\n                form.action = `/delete-event/${eventId}`;\n                document.body.appendChild(form);\n                form.submit();\n            });\n        });\n    });\n});\n\n// Apply all filters and redirect\nfunction applyFilters() {\n    const searchInput = document.getElementById('search_input');\n    const categorySelect = document.getElementById('category_filter');\n    const typeSelect = document.getElementById('type_filter');\n    const dateSelect = document.getElementById('date_filter');\n    const statusSelect = document.getElementById('status_filter');\n    \n    // Build query string\n    const params = new URLSearchParams();\n    \n    if (searchInput && searchInput.value.trim()) {\n        params.append('search', searchInput.value.trim());\n    }\n    \n    if (categorySelect && categorySelect.value !== 'all') {\n        params.append('category', categorySelect.value);\n    }\n    \n    if (typeSelect && typeSelect.value !== 'all') {\n        params.append('type', typeSelect.value);\n    }\n    \n    if (dateSelect && dateSelect.value !== 'all') {\n        params.append('date', dateSelect.value);\n    }\n    \n    if (statusSelect && statusSelect.value !== 'all') {\n        params.append('status', statusSelect.value);\n    }\n    \n    // Redirect with filters\n    window.location.href = `/events?${params.toString()}`;\n}\n\n// Function to clear all filters\nfunction clearFilters() {\n    // Reset all filter controls\n    const searchInput = document.getElementById('search_input');\n    if (searchInput) searchInput.value = '';\n    \n    const filterSelects = document.querySelectorAll('.filter-control');\n    filterSelects.forEach(select => {\n        select.value = 'all';\n    });\n    \n    // Redirect to events page without params\n    window.location.href = '/events';\n}\n\n// Toggle card view and list view\nfunction toggleView(viewType) {\n    const eventsContainer = document.getElementById('events_container');\n    const cardViewBtn = document.getElementById('card_view_btn');\n    const listViewBtn = document.getElementById('list_view_btn');\n    \n    if (viewType === 'card') {\n        eventsContainer.classList.remove('list-view');\n        eventsContainer.classList.add('card-view');\n        cardViewBtn.classList.add('active');\n        listViewBtn.classList.remove('active');\n        localStorage.setItem('events_view', 'card');\n    } else {\n        eventsContainer.classList.remove('card-view');\n        eventsContainer.classList.add('list-view');\n        listViewBtn.classList.add('active');\n        cardViewBtn.classList.remove('active');\n        localStorage.setItem('events_view', 'list');\n    }\n}\n\n// Load saved view preference\nfunction loadViewPreference() {\n    const savedView = localStorage.getItem('events_view') || 'card';\n    toggleView(savedView);\n}\n","size_bytes":4000},"static/js/main.js":{"content":"// Main JavaScript for PharmaEvents Application\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Initialize tooltips\n    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'));\n    tooltipTriggerList.map(function (tooltipTriggerEl) {\n        return new bootstrap.Tooltip(tooltipTriggerEl);\n    });\n\n    // Initialize popovers\n    var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"popover\"]'));\n    popoverTriggerList.map(function (popoverTriggerEl) {\n        return new bootstrap.Popover(popoverTriggerEl);\n    });\n\n    // Initialize user dropdown with proper positioning\n    const userDropdown = document.getElementById('userMenuDropdown');\n    if (userDropdown) {\n        const dropdown = new bootstrap.Dropdown(userDropdown, {\n            boundary: 'viewport',\n            display: 'static'\n        });\n        \n        // Add event listener to ensure proper positioning\n        userDropdown.addEventListener('shown.bs.dropdown', function () {\n            const dropdownMenu = this.nextElementSibling;\n            const rect = this.getBoundingClientRect();\n            const viewportWidth = window.innerWidth;\n            \n            // Ensure dropdown doesn't go off screen on the right\n            if (rect.right + dropdownMenu.offsetWidth > viewportWidth) {\n                dropdownMenu.style.right = '0';\n                dropdownMenu.style.left = 'auto';\n                dropdownMenu.style.transform = 'translateX(0)';\n            }\n        });\n    }\n\n    // Custom file input label\n    const fileInputs = document.querySelectorAll('.custom-file-input');\n    fileInputs.forEach(input => {\n        input.addEventListener('change', function(e) {\n            const fileName = this.files[0]?.name || 'Choose file';\n            const label = this.nextElementSibling;\n            label.textContent = fileName;\n        });\n    });\n\n    // Form validation\n    const forms = document.querySelectorAll('.needs-validation');\n    forms.forEach(form => {\n        form.addEventListener('submit', function(event) {\n            if (!form.checkValidity()) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            form.classList.add('was-validated');\n        }, false);\n    });\n\n    // Toggle online/offline event fields\n    const onlineCheckbox = document.getElementById('is_online');\n    if (onlineCheckbox) {\n        const venueFields = document.getElementById('venue_fields');\n        \n        // Initial state\n        toggleVenueFields();\n        \n        // Add change listener\n        onlineCheckbox.addEventListener('change', toggleVenueFields);\n        \n        function toggleVenueFields() {\n            if (onlineCheckbox.checked) {\n                venueFields.classList.add('d-none');\n            } else {\n                venueFields.classList.remove('d-none');\n            }\n        }\n    }\n\n    // Handle flash messages auto-close\n    const alerts = document.querySelectorAll('.alert:not(.alert-dismissible)');\n    alerts.forEach(alert => {\n        setTimeout(() => {\n            alert.classList.add('fade');\n            setTimeout(() => {\n                alert.remove();\n            }, 500);\n        }, 5000);\n    });\n\n    // Handle deletion confirmations\n    const deleteButtons = document.querySelectorAll('.btn-delete-item');\n    deleteButtons.forEach(button => {\n        button.addEventListener('click', function(e) {\n            if (!confirm('Are you sure you want to delete this item? This action cannot be undone.')) {\n                e.preventDefault();\n            }\n        });\n    });\n\n    // Handle image URL / file upload toggle\n    const imageUrlRadio = document.getElementById('image_url_option');\n    const fileUploadRadio = document.getElementById('file_upload_option');\n    \n    if (imageUrlRadio && fileUploadRadio) {\n        const imageUrlField = document.getElementById('image_url_field');\n        const fileUploadField = document.getElementById('file_upload_field');\n        \n        imageUrlRadio.addEventListener('change', toggleImageFields);\n        fileUploadRadio.addEventListener('change', toggleImageFields);\n        \n        // Initial state\n        toggleImageFields();\n        \n        function toggleImageFields() {\n            if (imageUrlRadio.checked) {\n                imageUrlField.classList.remove('d-none');\n                fileUploadField.classList.add('d-none');\n            } else {\n                imageUrlField.classList.add('d-none');\n                fileUploadField.classList.remove('d-none');\n            }\n        }\n    }\n\n    // Preview uploaded image\n    const eventBannerInput = document.getElementById('event_banner');\n    const previewContainer = document.getElementById('image_preview_container');\n    const previewImage = document.getElementById('image_preview');\n    \n    if (eventBannerInput && previewContainer && previewImage) {\n        eventBannerInput.addEventListener('change', function() {\n            const file = this.files[0];\n            if (file) {\n                const reader = new FileReader();\n                \n                reader.addEventListener('load', function() {\n                    previewImage.src = reader.result;\n                    previewContainer.classList.remove('d-none');\n                });\n                \n                reader.readAsDataURL(file);\n            } else {\n                previewContainer.classList.add('d-none');\n            }\n        });\n    }\n});\n\n// Show loading overlay during form submissions\nfunction showLoading() {\n    const loadingOverlay = document.getElementById('loading_overlay');\n    if (loadingOverlay) {\n        loadingOverlay.style.display = 'flex';\n    }\n}\n\n// Date/time formatting helper\nfunction formatDateTime(dateTimeStr) {\n    const date = new Date(dateTimeStr);\n    return date.toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n    });\n}\n\n// Function to show confirmation dialog\nfunction confirmAction(message, callback) {\n    if (confirm(message)) {\n        callback();\n    }\n}\n\n// Function to format a date object to YYYY-MM-DD for inputs\nfunction formatDateForInput(date) {\n    return date.toISOString().split('T')[0];\n}\n\n// Function to format a date object to HH:MM for inputs\nfunction formatTimeForInput(date) {\n    return date.toTimeString().substring(0, 5);\n}\n","size_bytes":6451},"static/js/settings.js":{"content":"document.addEventListener('DOMContentLoaded', function() {\n    // Utility function to show alerts\n    function showAlert(message, type = 'info') {\n        const alertsContainer = document.querySelector('.container-fluid');\n        const alert = document.createElement('div');\n        alert.className = `alert alert-${type} alert-dismissible fade show`;\n        alert.innerHTML = `\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\n        `;\n        alertsContainer.insertBefore(alert, alertsContainer.firstChild);\n\n        // Auto-dismiss after 5 seconds\n        setTimeout(() => {\n            if (alert.parentNode) {\n                alert.remove();\n            }\n        }, 5000);\n    }\n\n    // Theme color picker\n    const themeColorInput = document.getElementById('theme_color');\n    const presetColors = document.querySelectorAll('.preset-color');\n\n    if (themeColorInput) {\n        themeColorInput.addEventListener('change', function() {\n            updateThemeColor(this.value);\n        });\n    }\n\n    if (presetColors) {\n        presetColors.forEach(colorBtn => {\n            colorBtn.addEventListener('click', function() {\n                const color = this.getAttribute('data-color');\n                if (themeColorInput) {\n                    themeColorInput.value = color;\n                }\n                updateThemeColor(color);\n            });\n        });\n    }\n\n    function updateThemeColor(color) {\n        fetch('/api/settings/theme', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            credentials: 'same-origin',\n            body: JSON.stringify({ theme_color: color })\n        })\n        .then(response => response.json())\n        .then(data => {\n            if (data.success) {\n                // Apply theme immediately\n                document.documentElement.style.setProperty('--primary', color);\n                showAlert('Theme color updated successfully!', 'success');\n            } else {\n                console.error('Theme update error:', data);\n                showAlert(data.error || 'Error updating theme color', 'danger');\n            }\n        })\n        .catch(error => {\n            console.error('Error updating theme color:', error);\n            showAlert('Error updating theme color', 'danger');\n        });\n    }\n\n    // App name update\n    const appNameInput = document.getElementById('app_name');\n    const updateAppBtn = document.getElementById('update_app_name');\n\n    if (appNameInput && updateAppBtn) {\n        updateAppBtn.addEventListener('click', function() {\n            const appName = appNameInput.value.trim();\n            if (!appName) {\n                showAlert('App name cannot be empty', 'warning');\n                return;\n            }\n\n            fetch('/api/settings/app', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                credentials: 'same-origin',\n                body: JSON.stringify({ name: appName })\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('App name updated successfully! Refreshing page...', 'success');\n                    setTimeout(() => location.reload(), 1500);\n                } else {\n                    showAlert(data.error || 'Error updating app name', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error updating app name', 'danger');\n            });\n        });\n    }\n\n    // Logo upload\n    const logoInput = document.getElementById('app_logo');\n    const uploadLogoBtn = document.getElementById('upload_logo');\n\n    if (logoInput && uploadLogoBtn) {\n        uploadLogoBtn.addEventListener('click', function() {\n            const file = logoInput.files[0];\n            if (!file) {\n                showAlert('Please select a file first', 'warning');\n                return;\n            }\n\n            // Validate file type\n            const allowedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml'];\n            if (!allowedTypes.includes(file.type)) {\n                showAlert('Please select a PNG, JPG, or SVG file', 'danger');\n                return;\n            }\n\n            // Validate file size (2MB max)\n            if (file.size > 2 * 1024 * 1024) {\n                showAlert('File size must be less than 2MB', 'danger');\n                return;\n            }\n\n            const formData = new FormData();\n            formData.append('logo', file);\n\n            fetch('/api/settings/logo', {\n                method: 'POST',\n                credentials: 'same-origin',\n                body: formData\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('Logo updated successfully! Refreshing page...', 'success');\n                    setTimeout(() => location.reload(), 1500);\n                } else {\n                    showAlert(data.error || 'Error updating logo', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error updating logo', 'danger');\n            });\n        });\n    }\n\n    // Logo removal\n    const removeLogoBtn = document.getElementById('remove_logo');\n    if (removeLogoBtn) {\n        removeLogoBtn.addEventListener('click', function() {\n            if (confirm('Are you sure you want to remove the current logo? This action cannot be undone.')) {\n                fetch('/api/settings/logo', {\n                    method: 'DELETE',\n                    credentials: 'same-origin'\n                })\n                .then(response => response.json())\n                .then(data => {\n                    if (data.success) {\n                        showAlert('Logo removed successfully! Refreshing page...', 'success');\n                        setTimeout(() => location.reload(), 1500);\n                    } else {\n                        showAlert(data.error || 'Error removing logo', 'danger');\n                    }\n                })\n                .catch(error => {\n                    console.error('Error:', error);\n                    showAlert('Error removing logo', 'danger');\n                });\n            }\n        });\n    }\n\n    // Login content update\n    const updateLoginContentBtn = document.getElementById('update_login_content');\n    if (updateLoginContentBtn) {\n        updateLoginContentBtn.addEventListener('click', function() {\n            const loginContentData = {\n                main_tagline: document.getElementById('main_tagline')?.value || '',\n                main_header: document.getElementById('main_header')?.value || '',\n                app_description: document.getElementById('app_description')?.value || '',\n                feature1_title: document.getElementById('feature1_title')?.value || '',\n                feature1_description: document.getElementById('feature1_description')?.value || '',\n                feature2_title: document.getElementById('feature2_title')?.value || '',\n                feature2_description: document.getElementById('feature2_description')?.value || ''\n            };\n\n            fetch('/api/settings/login-content', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                credentials: 'same-origin',\n                body: JSON.stringify(loginContentData)\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('Login content updated successfully!', 'success');\n                } else {\n                    showAlert(data.error || 'Error updating login content', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error updating login content', 'danger');\n            });\n        });\n    }\n\n    // Category management\n    const addCategoryForm = document.getElementById('add_category_form');\n    if (addCategoryForm) {\n        addCategoryForm.addEventListener('submit', function(e) {\n            e.preventDefault();\n            const categoryName = document.getElementById('category_name').value;\n\n            const formData = new FormData();\n            formData.append('category_name', categoryName);\n\n            fetch('/api/categories', {\n                method: 'POST',\n                credentials: 'same-origin',\n                body: formData\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('Category added successfully!', 'success');\n                    setTimeout(() => location.reload(), 1000);\n                } else {\n                    showAlert(data.error || 'Error adding category', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error adding category', 'danger');\n            });\n        });\n    }\n\n    // Event Type management\n    const addEventTypeForm = document.getElementById('add_type_form');\n    if (addEventTypeForm) {\n        addEventTypeForm.addEventListener('submit', function(e) {\n            e.preventDefault();\n            const typeName = document.getElementById('type_name').value;\n\n            const formData = new FormData();\n            formData.append('type_name', typeName);\n\n            fetch('/api/event-types', {\n                method: 'POST',\n                credentials: 'same-origin',\n                body: formData\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('Event type added successfully!', 'success');\n                    setTimeout(() => location.reload(), 1000);\n                } else {\n                    showAlert(data.error || 'Error adding event type', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error adding event type', 'danger');\n            });\n        });\n    }\n\n    // Delete category buttons\n    const deleteCategoryBtns = document.querySelectorAll('.btn-delete-category');\n    deleteCategoryBtns.forEach(btn => {\n        btn.addEventListener('click', function() {\n            const categoryId = this.getAttribute('data-id');\n            const categoryName = this.getAttribute('data-name');\n            if (confirm(`Are you sure you want to delete category \"${categoryName}\"?`)) {\n                fetch(`/api/categories/${categoryId}`, {\n                    method: 'DELETE',\n                    credentials: 'same-origin'\n                })\n                .then(response => response.json())\n                .then(data => {\n                    if (data.success) {\n                        showAlert('Category deleted successfully!', 'success');\n                        setTimeout(() => location.reload(), 1000);\n                    } else {\n                        showAlert(data.error || 'Error deleting category', 'danger');\n                    }\n                })\n                .catch(error => {\n                    console.error('Error:', error);\n                    showAlert('Error deleting category', 'danger');\n                });\n            }\n        });\n    });\n\n    // Delete event type buttons\n    const deleteEventTypeBtns = document.querySelectorAll('.btn-delete-type');\n    deleteEventTypeBtns.forEach(btn => {\n        btn.addEventListener('click', function() {\n            const typeId = this.getAttribute('data-id');\n            const typeName = this.getAttribute('data-name');\n            if (confirm(`Are you sure you want to delete event type \"${typeName}\"?`)) {\n                fetch(`/api/event-types/${typeId}`, {\n                    method: 'DELETE',\n                    credentials: 'same-origin'\n                })\n                .then(response => response.json())\n                .then(data => {\n                    if (data.success) {\n                        showAlert('Event type deleted successfully!', 'success');\n                        setTimeout(() => location.reload(), 1000);\n                    } else {\n                        showAlert(data.error || 'Error deleting event type', 'danger');\n                    }\n                })\n                .catch(error => {\n                    console.error('Error:', error);\n                    showAlert('Error deleting event type', 'danger');\n                });\n            }\n        });\n    });\n\n    // User management\n    const addUserForm = document.getElementById('add_user_form');\n    if (addUserForm) {\n        addUserForm.addEventListener('submit', function(e) {\n            e.preventDefault();\n\n            const email = document.getElementById('user_email').value;\n            const password = document.getElementById('user_password').value;\n            const role = document.getElementById('user_role').value;\n\n            const formData = new FormData();\n            formData.append('email', email);\n            formData.append('password', password);\n            formData.append('role', role);\n\n            fetch('/api/users', {\n                method: 'POST',\n                credentials: 'same-origin',\n                body: formData\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('User added successfully!', 'success');\n                    setTimeout(() => location.reload(), 1000);\n                } else {\n                    showAlert(data.error || 'Error adding user', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error adding user', 'danger');\n            });\n        });\n    }\n\n    // Delete user buttons\n    const deleteUserBtns = document.querySelectorAll('.btn-delete-user');\n    deleteUserBtns.forEach(btn => {\n        btn.addEventListener('click', function() {\n            const userId = this.getAttribute('data-id');\n            if (confirm('Are you sure you want to delete this user?')) {\n                fetch(`/api/users/${userId}`, {\n                    method: 'DELETE',\n                    credentials: 'same-origin'\n                })\n                .then(response => response.json())\n                .then(data => {\n                    if (data.success) {\n                        showAlert('User deleted successfully!', 'success');\n                        setTimeout(() => location.reload(), 1000);\n                    } else {\n                        showAlert(data.error || 'Error deleting user', 'danger');\n                    }\n                })\n                .catch(error => {\n                    console.error('Error:', error);\n                    showAlert('Error deleting user', 'danger');\n                });\n            }\n        });\n    });\n\n    // API Token Management\n    const createTokenForm = document.getElementById('create_token_form');\n    if (createTokenForm) {\n        createTokenForm.addEventListener('submit', function(e) {\n            e.preventDefault();\n            const tokenName = document.getElementById('token_name').value.trim();\n            \n            if (!tokenName) {\n                showAlert('Please enter a token name', 'warning');\n                return;\n            }\n            \n            fetch('/api/tokens', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                credentials: 'same-origin',\n                body: JSON.stringify({ name: tokenName })\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    document.getElementById('new_token_value').value = data.token;\n                    const modal = new bootstrap.Modal(document.getElementById('tokenModal'));\n                    modal.show();\n                    document.getElementById('token_name').value = '';\n                    loadTokens();\n                } else {\n                    showAlert(data.error || 'Error creating token', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error creating token', 'danger');\n            });\n        });\n    }\n\n    // Load tokens function\n    function loadTokens() {\n        // Only load tokens if the tokens list element exists\n        const tokensList = document.getElementById('tokens_list');\n        if (!tokensList) {\n            return; // Exit early if tokens section doesn't exist\n        }\n        \n        fetch('/api/tokens', {\n            method: 'GET',\n            credentials: 'same-origin'\n        })\n        .then(response => {\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            return response.json();\n        })\n        .then(data => {\n            const tokensList = document.getElementById('tokens_list');\n            if (data.tokens && data.tokens.length > 0) {\n                let html = '<div class=\"table-responsive\"><table class=\"table table-sm\">';\n                html += '<thead><tr><th>Name</th><th>Created</th><th>Last Used</th><th>Actions</th></tr></thead><tbody>';\n                \n                data.tokens.forEach(token => {\n                    const createdDate = new Date(token.created_at).toLocaleDateString();\n                    const lastUsed = token.last_used ? new Date(token.last_used).toLocaleDateString() : 'Never';\n                    \n                    html += `<tr>\n                        <td>${token.name}</td>\n                        <td>${createdDate}</td>\n                        <td>${lastUsed}</td>\n                        <td>\n                            <button class=\"btn btn-sm btn-danger\" onclick=\"deleteToken(${token.id}, '${token.name}')\">Delete</button>\n                        </td>\n                    </tr>`;\n                });\n                \n                html += '</tbody></table></div>';\n                tokensList.innerHTML = html;\n            } else {\n                tokensList.innerHTML = '<p class=\"text-muted\">No active tokens found.</p>';\n            }\n        })\n        .catch(error => {\n            console.error('Error loading tokens:', error);\n            // Only show user-facing error if this was an intentional load\n            const tokensList = document.getElementById('tokens_list');\n            if (tokensList) {\n                tokensList.innerHTML = '<div class=\"text-muted\">API tokens not available</div>';\n            }\n        });\n    }\n\n    // Load tokens on page load only if the tokens section exists\n    if (document.getElementById('tokens_list')) {\n        loadTokens();\n    }\n\n    // Copy token function\n    window.copyToken = function() {\n        const tokenInput = document.getElementById('new_token_value');\n        tokenInput.select();\n        document.execCommand('copy');\n        showAlert('Token copied to clipboard!', 'success');\n    };\n\n    // Delete token function\n    window.deleteToken = function(tokenId, tokenName) {\n        if (confirm(`Are you sure you want to delete the token \"${tokenName}\"? This action cannot be undone.`)) {\n            fetch(`/api/tokens/${tokenId}`, {\n                method: 'DELETE',\n                credentials: 'same-origin'\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('Token deleted successfully!', 'success');\n                    loadTokens();\n                } else {\n                    showAlert(data.error || 'Error deleting token', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error deleting token', 'danger');\n            });\n        }\n    };\n\n    // Database backup functionality\n    const backupButton = document.getElementById('backup_database');\n    if (backupButton) {\n        backupButton.addEventListener('click', function() {\n            const button = this;\n            const originalText = button.innerHTML;\n            \n            // Show loading state\n            button.disabled = true;\n            button.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i> Creating Backup...';\n            \n            fetch('/api/database/backup', {\n                method: 'POST',\n                credentials: 'same-origin'\n            })\n            .then(response => {\n                if (response.ok) {\n                    // Get the filename from the response headers or use a default\n                    const filename = response.headers.get('Content-Disposition')?.match(/filename=\"(.+)\"/)?.[1] || 'database_backup.sql';\n                    return response.blob().then(blob => ({ blob, filename }));\n                } else {\n                    return response.json().then(data => Promise.reject(data));\n                }\n            })\n            .then(({ blob, filename }) => {\n                // Create download link\n                const url = window.URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                a.href = url;\n                a.download = filename;\n                document.body.appendChild(a);\n                a.click();\n                window.URL.revokeObjectURL(url);\n                document.body.removeChild(a);\n                \n                showAlert('Database backup downloaded successfully!', 'success');\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert(error.error || 'Error creating database backup', 'danger');\n            })\n            .finally(() => {\n                // Restore button state\n                button.disabled = false;\n                button.innerHTML = originalText;\n            });\n        });\n    }\n\n    // Database restore functionality\n    const restoreButton = document.getElementById('restore_database');\n    if (restoreButton) {\n        restoreButton.addEventListener('click', function() {\n            const fileInput = document.getElementById('restore_file');\n            const file = fileInput.files[0];\n            \n            if (!file) {\n                showAlert('Please select a backup file first', 'warning');\n                return;\n            }\n            \n            // Validate file type\n            if (!file.name.endsWith('.sql')) {\n                showAlert('Please select a valid SQL backup file', 'danger');\n                return;\n            }\n            \n            // Confirm the destructive action\n            if (!confirm('This will permanently replace ALL current data with the backup. Are you absolutely sure you want to continue?')) {\n                return;\n            }\n            \n            const button = this;\n            const originalText = button.innerHTML;\n            \n            // Show loading state\n            button.disabled = true;\n            button.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i> Restoring...';\n            \n            const formData = new FormData();\n            formData.append('backup_file', file);\n            \n            fetch('/api/database/restore', {\n                method: 'POST',\n                credentials: 'same-origin',\n                body: formData\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    showAlert('Database restored successfully! The page will refresh...', 'success');\n                    setTimeout(() => location.reload(), 2000);\n                } else {\n                    showAlert(data.error || 'Error restoring database', 'danger');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                showAlert('Error restoring database', 'danger');\n            })\n            .finally(() => {\n                // Restore button state\n                button.disabled = false;\n                button.innerHTML = originalText;\n                fileInput.value = ''; // Clear the file input\n            });\n        });\n    }\n});","size_bytes":24779},".local/state/replit/agent/progress_tracker.md":{"content":"[x] 1. Install the required packages\n[x] 2. Restart the workflow to see if the project is working\n[x] 3. Verify the project is working using the feedback tool\n[ ] 4. Inform user the import is completed and they can start building, mark the import as completed using the complete_project_import tool","size_bytes":298},"static/js/loading.js":{"content":"// Performance optimized loading overlay\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Hide loading overlay faster\n    const loadingOverlay = document.getElementById('loading_overlay');\n    if (loadingOverlay) {\n        loadingOverlay.style.display = 'none';\n    }\n\n    // Optimize page transitions\n    const navLinks = document.querySelectorAll('a.nav-link');\n    navLinks.forEach(link => {\n        link.addEventListener('click', function(e) {\n            // Show loading for navigation only if it's a different page\n            if (this.href !== window.location.href) {\n                if (loadingOverlay) {\n                    loadingOverlay.style.display = 'flex';\n                }\n            }\n        });\n    });\n\n    // Hide loading on back/forward navigation\n    window.addEventListener('pageshow', function() {\n        if (loadingOverlay) {\n            loadingOverlay.style.display = 'none';\n        }\n    });\n});","size_bytes":944}}}